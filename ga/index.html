<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NguyeZ Gaming Give Away</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
            color: #fff;
        }

        .container {
            display: flex;
            height: 100vh;
            padding: 20px;
            gap: 20px;
        }

        .left-panel {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            max-height: calc(100vh - 80px);
            padding-right: 10px;
        }

        .left-panel::-webkit-scrollbar {
            width: 6px;
        }

        .left-panel::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
        }

        .title {
            text-align: center;
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
        }

        .input-section {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            max-height: 180px;
            overflow: hidden;
        }

        .input-section.scrollable {
            max-height: 200px;
            overflow-y: auto;
        }

        .input-section h3 {
            margin-bottom: 10px;
            font-size: 18px;
            text-align: center;
        }

        .input-section textarea {
            min-height: 80px;
            max-height: 130px;
            padding: 8px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            background: rgba(255,255,255,0.9);
            color: #333;
            font-size: 13px;
            resize: none;
            font-family: 'Courier New', monospace;
            overflow-y: auto;
            line-height: 1.6;
        }

        .input-section textarea:focus {
            outline: none;
            border-color: #fff;
        }

        .start-btn {
            padding: 15px 30px;
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, opacity 0.2s;
            flex: 1;
        }

        .start-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .start-btn:active:not(:disabled) {
            transform: translateY(0);
        }

        .start-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 0;
            overflow: hidden;
        }

        .zone3 {
            flex: 1;
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 10px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-width: 0;
            max-width: 100%;
            box-sizing: border-box;
        }

        .grid-wrapper {
            flex: 1;
            overflow: auto;
            position: relative;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            min-width: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .grid-container {
            display: grid;
            gap: 4px;
            width: 100%;
            height: 100%;
            min-height: 0;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        .grid-container > .cell {
            aspect-ratio: 1;
            min-width: 0;
            min-height: 0;
        }

        .grid-label {
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            color: #fff;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }

        .grid-label.row {
            grid-column: 1;
        }

        .grid-label.col {
            grid-row: 1;
        }

        .cell {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            position: relative;
            transition: all 0.3s;
            cursor: pointer;
            padding: 5px;
            text-align: center;
            word-wrap: break-word;
            overflow: hidden;
            min-width: 0;
            width: 100%;
            height: 100%;
        }

        .cell::after {
            content: attr(data-cell-number);
            position: absolute;
            bottom: 3px;
            right: 5px;
            font-size: 14px;
            color: rgba(255,255,255,0.7);
            font-weight: bold;
            line-height: 1;
            z-index: 5;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        /* √î s·ª± ki·ªán: d√πng ::before cho s·ªë th·ª© t·ª±, ::after cho tooltip */
        .cell.event::before {
            content: attr(data-cell-number);
            position: absolute;
            bottom: 3px;
            right: 5px;
            font-size: 14px;
            color: rgba(255,255,255,0.7);
            font-weight: bold;
            line-height: 1;
            z-index: 5;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .cell:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.05);
        }

        .cell.player {
            background: #ddd;
            font-weight: 500;
            color: #14b84c;
            font-size: 17px;
            white-space: normal;
            word-wrap: break-word;
            line-height: 1.2;
        }

        .cell.player.dead {
            background: #3c3c3c;
            color: #ecf0f1;
            border: 2px solid #2c2c2c;
        }

        .cell.player.dead::before {
            content: "üíÄ ";
            font-size: 24px;
            margin-right: 2px;
        }

        .cell.player.winner {
            background: #f39c12;
            color: #2c3e50;
            border: 2px solid #d68910;
        }

        .cell.player.winner::before {
            content: "üèÜ ";
            font-size: 20px;
            margin-right: 2px;
        }
        
        /* ƒê·∫£m b·∫£o t√™n v·∫´n hi·ªÉn th·ªã khi c√≥ icon c√∫p */
        .cell.player.winner {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Event cells - Di chuy·ªÉn (Movement) - M√†u flat */
        .cell.event.movement {
            background: #3498db;
            font-weight: bold;
            font-size: 32px;
            position: relative;
            border: 2px solid #2980b9;
        }

        /* Event cells - T·∫•n c√¥ng (Attack) - M√†u flat */
        .cell.event.attack {
            background: #e74c3c;
            font-weight: bold;
            font-size: 32px;
            position: relative;
            border: 2px solid #c0392b;
        }

        /* Event cells - Ph√≤ng th·ªß (Defense) - M√†u flat */
        .cell.event.defense {
            background: #2ecc71;
            font-weight: bold;
            font-size: 32px;
            position: relative;
            border: 2px solid #27ae60;
        }

        .cell.event {
            position: relative;
        }

        .cell.event::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(100% + 5px);
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            background: rgba(0,0,0,0.9);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s, transform 0.3s;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            min-width: fit-content;
            width: auto;
            box-sizing: border-box;
            display: block;
        }

        .cell.event:hover::after {
            opacity: 1;
            transform: translateX(-50%) translateY(-5px);
        }

        /* Tooltip cho c√°c lo·∫°i event */
        .cell[data-event-type="move_forward"]::after {
            content: "‚¨ÜÔ∏è Di chuy·ªÉn: Ti·∫øn th√™m 1-5 √¥";
        }

        .cell[data-event-type="move_backward"]::after {
            content: "‚¨áÔ∏è Di chuy·ªÉn: L√πi 1-3 √¥";
        }

        .cell[data-event-type="jump_row"]::after {
            content: "‚¨áÔ∏è Di chuy·ªÉn: Nh·∫£y xu·ªëng h√†ng d·ªçc";
        }

        .cell[data-event-type="jump_col"]::after {
            content: "‚û°Ô∏è Di chuy·ªÉn: Nh·∫£y sang h√†ng ngang";
        }

        .cell[data-event-type="go_back"]::after {
            content: "üîô Di chuy·ªÉn: ƒêi ng∆∞·ª£c v·ªÅ";
        }

        .cell[data-event-type="hop"]::after {
            content: "ü¶ò Di chuy·ªÉn: ƒêi nh·∫£y c√≥c (m·ªói l·∫ßn 2 √¥)";
        }

        .cell[data-event-type="portal"]::after {
            content: "üåÄ Di chuy·ªÉn: Portal - ƒêi t·∫Øt sang √¥ kia";
        }

        .cell[data-event-type="kill_random"]::after {
            content: "‚öîÔ∏è T·∫•n c√¥ng: Ti√™u di·ªát ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n";
        }

        .cell[data-event-type="kill_forward"]::after {
            content: "‚öîÔ∏è T·∫•n c√¥ng: Ti√™u di·ªát ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t ph√≠a tr∆∞·ªõc";
        }

        .cell[data-event-type="kill_backward"]::after {
            content: "‚öîÔ∏è T·∫•n c√¥ng: Ti√™u di·ªát ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t ph√≠a sau";
        }

        .cell[data-event-type="bomb_row"]::after {
            content: "üí£ T·∫•n c√¥ng: Bom h√†ng ngang - Ng∆∞·ªùi ch∆°i c√πng h√†ng ch·∫øt h·∫øt";
        }

        .cell[data-event-type="bomb_col"]::after {
            content: "üí£ T·∫•n c√¥ng: Bom h√†ng d·ªçc - Ng∆∞·ªùi ch∆°i c√πng c·ªôt ch·∫øt h·∫øt";
        }

        .cell[data-event-type="bomb_cross"]::after {
            content: "üí• T·∫•n c√¥ng: Bom ch·ªØ th·∫≠p - Ng∆∞·ªùi ch∆°i c√πng h√†ng v√† c·ªôt ch·∫øt h·∫øt";
        }

        .cell[data-event-type="shield"]::after {
            content: "üõ°Ô∏è Ph√≤ng th·ªß: T·∫°o khi√™n cho 1-3 ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n + th√™m √¥ khi√™n (20% s·ªë √¥ t·∫•n c√¥ng)";
        }

        .cell.current {
            box-shadow: 0 0 20px #00ff00;
            border-color: #00ff00;
            z-index: 10;
        }

        .cell.visited {
            background: rgba(0, 0, 0, 0.3);
        }

        .game-piece {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: top 0.3s ease-out, left 0.3s ease-out, opacity 0.3s ease;
            z-index: 100;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            overflow: hidden;
            pointer-events: none;
        }

        .cell.player .game-piece,
        .cell.event .game-piece {
            opacity: 0.3;
        }

        .game-piece img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
            display: block;
        }

        .zone999 {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 12px;
            max-height: 180px;
            overflow-y: auto;
        }

        .zone999 h3 {
            margin-bottom: 8px;
            text-align: center;
            font-size: 16px;
        }

        .result-item {
            background: rgba(255,255,255,0.2);
            padding: 6px 10px;
            margin-bottom: 4px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }

        .event-info-section {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .event-info-section h3 {
            margin-bottom: 8px;
            text-align: center;
            font-size: 16px;
        }

        .event-info-item {
            padding: 6px 8px;
            margin: 4px 0;
            border-radius: 4px;
            font-size: 12px;
            background: rgba(255,255,255,0.1);
        }

        .event-info-item.movement {
            border-left: 3px solid #4facfe;
        }

        .event-info-item.attack {
            border-left: 3px solid #f5576c;
        }

        .event-info-item.defense {
            border-left: 3px solid #43e97b;
        }

        .history-section {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 12px;
            max-height: 200px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .history-section::-webkit-scrollbar {
            width: 6px;
        }

        .history-section::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
        }

        .history-section h3 {
            margin-bottom: 8px;
            text-align: center;
            font-size: 16px;
            flex-shrink: 0;
        }

        .history-item {
            background: rgba(255,255,255,0.1);
            padding: 6px 8px;
            margin: 4px 0;
            border-radius: 4px;
            font-size: 12px;
            border-left: 3px solid rgba(255,255,255,0.3);
            flex-shrink: 0;
        }

        #historyContainer {
            flex: 1;
            overflow-y: auto;
        }

        #historyContainer::-webkit-scrollbar {
            width: 6px;
        }

        #historyContainer::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
        }

        .congratulations {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            padding: 40px 60px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 2000;
            display: none;
            text-align: center;
            animation: popIn 0.5s ease-out;
        }

        .congratulations.active {
            display: block;
        }

        @keyframes popIn {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .congratulations h2 {
            font-size: 36px;
            margin-bottom: 15px;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .congratulations p {
            font-size: 24px;
            color: #fff;
            margin: 10px 0;
        }

        .dice-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 20px;
            display: none;
            z-index: 1000;
            text-align: center;
        }

        .dice-container.active {
            display: block;
        }

        .dice {
            font-size: 100px;
            animation: roll 0.5s infinite;
        }

        @keyframes roll {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(90deg); }
            50% { transform: rotate(180deg); }
            75% { transform: rotate(270deg); }
        }

        .dice-result {
            font-size: 24px;
            margin-top: 20px;
            color: #fff;
        }

        .file-upload {
            margin-bottom: 10px;
        }

        .file-upload input {
            display: none;
        }

        .file-upload label {
            display: block;
            padding: 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: background 0.3s;
        }

        .file-upload label:hover {
            background: rgba(255,255,255,0.3);
        }

        .uploaded-image {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin: 10px auto;
            display: block;
        }

        .dice-btn {
            padding: 15px 30px;
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: none;
            margin: 10px auto;
            width: fit-content;
        }

        .dice-btn-container {
            padding: 10px;
            text-align: center;
        }

        .dice-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .dice-btn:active {
            transform: translateY(0);
        }

        .dice-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .event-display {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            margin-top: 10px;
            min-height: 80px;
            display: none;
        }

        .event-display.active {
            display: block;
        }

        .event-display h4 {
            margin-bottom: 10px;
            font-size: 18px;
            color: #fee140;
        }

        .event-display p {
            font-size: 16px;
            line-height: 1.5;
        }

        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            text-align: center;
            font-size: 14px;
            color: #fff;
            z-index: 100;
            border-top: 1px solid rgba(255,255,255,0.2);
        }

        .footer a {
            color: #4facfe;
            text-decoration: none;
            transition: color 0.3s;
        }

        .footer a:hover {
            color: #00f2fe;
            text-decoration: underline;
        }

        body {
            padding-bottom: 50px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="left-panel">
            <div class="title">NguyeZ Gaming Give Away</div>
            
            <div class="input-section">
                <h3>üë• Danh s√°ch ng∆∞·ªùi ch∆°i</h3>
                <textarea id="playersInput" placeholder="M·ªói d√≤ng l√† 1 ng∆∞·ªùi ch∆°i&#10;V√≠ d·ª•:&#10;1. Ng∆∞·ªùi ch∆°i 1&#10;2. Ng∆∞·ªùi ch∆°i 2"></textarea>
            </div>

            <div class="input-section">
                <h3>Danh s√°ch ph·∫ßn th∆∞·ªüng üéÅ</h3>
                <textarea id="prizesInput" placeholder="M·ªói d√≤ng l√† 1 ph·∫ßn th∆∞·ªüng&#10;V√≠ d·ª•:&#10;1. Ph·∫ßn th∆∞·ªüng 1&#10;2. Ph·∫ßn th∆∞·ªüng 2"></textarea>
            </div>

            <div class="event-info-section">
                <h3>üìã C√°c S·ª± Ki·ªán</h3>
                <div id="luckyCountdown" style="font-size: 11px; color: #ffd700; margin-bottom: 8px; padding: 5px; background: rgba(255,215,0,0.1); border-radius: 4px;">
                    üí° Sau m·ªói 7 l∆∞·ª£t gieo x√≠ ng·∫ßu, 25% ng∆∞·ªùi ch∆°i may m·∫Øn s·∫Ω ƒë∆∞·ª£c th√™m v√†o c√°c √¥ tr·ªëng!
                </div>
                <div class="event-info-item movement">‚¨ÜÔ∏è Di chuy·ªÉn: Ti·∫øn th√™m 1-5 √¥</div>
                <div class="event-info-item movement">‚¨áÔ∏è Di chuy·ªÉn: L√πi 1-3 √¥ (l√πi ·ªü l·∫ßn gieo x√≠ ng·∫ßu ti·∫øp theo)</div>
                <div class="event-info-item movement">‚¨áÔ∏è Di chuy·ªÉn: Nh·∫£y xu·ªëng h√†ng d·ªçc</div>
                <div class="event-info-item movement">‚û°Ô∏è Di chuy·ªÉn: Nh·∫£y sang h√†ng ngang</div>
                <div class="event-info-item movement">üîô Di chuy·ªÉn: ƒêi ng∆∞·ª£c v·ªÅ</div>
                <div class="event-info-item movement">üåÄ Di chuy·ªÉn: Portal - ƒêi t·∫Øt sang √¥ kia</div>
                <div class="event-info-item attack">‚öîÔ∏è T·∫•n c√¥ng: Ti√™u di·ªát ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n</div>
                <div class="event-info-item attack">‚öîÔ∏è T·∫•n c√¥ng: Ti√™u di·ªát ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t ph√≠a tr∆∞·ªõc</div>
                <div class="event-info-item attack">‚öîÔ∏è T·∫•n c√¥ng: Ti√™u di·ªát ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t ph√≠a sau</div>
                <div class="event-info-item attack">üí£ T·∫•n c√¥ng: Bom h√†ng ngang</div>
                <div class="event-info-item attack">üí£ T·∫•n c√¥ng: Bom h√†ng d·ªçc</div>
                <div class="event-info-item attack">üí• T·∫•n c√¥ng: Bom ch·ªØ th·∫≠p (ngang + d·ªçc)</div>
                <div class="event-info-item attack">üí£üí• T·∫•n c√¥ng: Bom n·∫£y - n·ªï x l·∫ßn m·ªói 2-3 √¥</div>
                <div class="event-info-item defense">üõ°Ô∏è Ph√≤ng th·ªß: T·∫°o khi√™n cho 1-3 ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n + th√™m √¥ khi√™n</div>
            </div>

            <div class="file-upload">
                <label for="avatarUpload">üì∑ Upload ·∫£nh ƒë·∫°i di·ªán qu√¢n c·ªù</label>
                <input type="file" id="avatarUpload" accept="image/*">
                <img id="avatarPreview" class="uploaded-image" style="display: none;">
            </div>

            <div style="display: flex; gap: 10px; margin: 15px 0;">
                <button class="start-btn" id="startBtn">Nh√¢n Ph·∫©m</button>
                <button class="start-btn" id="clearBtn" style="background: #f5576c;">X√ìA</button>
            </div>
            
            <div class="event-display" id="eventDisplay">
                <h4>‚ö° S·ª± Ki·ªán</h4>
                <p id="eventText"></p>
            </div>

            <div class="zone999">
                <h3>üèÜ K·∫øt qu·∫£ trao th∆∞·ªüng</h3>
                <div id="resultsContainer"></div>
            </div>

            <div class="history-section">
                <h3>üìú L·ªãch S·ª≠ S·ª± Ki·ªán</h3>
                <div id="historyContainer"></div>
            </div>
        </div>

        <div class="right-panel">
            <div class="zone3" id="zone3">
                <div class="grid-wrapper">
                    <div class="grid-container" id="gridContainer"></div>
                </div>
                <div class="dice-btn-container">
                    <button class="dice-btn" id="diceBtn">üé≤ Gieo X√≠ Ng·∫ßu</button>
                </div>
            </div>
        </div>
    </div>

    <div class="dice-container" id="diceContainer">
        <div class="dice">üé≤</div>
        <div class="dice-result" id="diceResult"></div>
    </div>

    <div class="congratulations" id="congratulations">
        <h2>üéâ Ch√∫c M·ª´ng! üéâ</h2>
        <p id="congratsPlayer"></p>
        <p id="congratsPrize"></p>
    </div>

    <footer class="footer">
        Design by <a href="https://youtube.com/ncn1992vn" target="_blank" rel="noopener noreferrer">Ncn - NguyeZ Gaming</a>
    </footer>

    <script>
        let players = [];
        let prizes = [];
        let cells = [];
        let currentPosition = 0;
        let gamePiece = null;
        let avatarImage = null;
        let eventCells = [];
        let gameStarted = false;
        let isMoving = false;
        let eventData = {}; // L∆∞u th√¥ng tin event cho m·ªói cell
        let playerShields = {}; // L∆∞u shield cho m·ªói player
        let deadPlayers = new Set(); // L∆∞u danh s√°ch player ƒë√£ ch·∫øt
        let portalPairs = []; // L∆∞u c·∫∑p portal
        let playerWinners = new Set(); // L∆∞u danh s√°ch player ƒë√£ tr√∫ng th∆∞·ªüng
        let originalPlayers = []; // L∆∞u danh s√°ch player g·ªëc
        let originalPrizes = []; // L∆∞u danh s√°ch prize g·ªëc
        let gameHistory = []; // L∆∞u l·ªãch s·ª≠ s·ª± ki·ªán
        let turnCount = 0; // ƒê·∫øm s·ªë l∆∞·ª£t ch∆°i
        let roundCount = 0; // ƒê·∫øm s·ªë v√≤ng (m·ªói 2 l∆∞·ª£t = 1 v√≤ng)
        let playerRepeatMultiplier = 1; // H·ªá s·ªë l·∫∑p l·∫°i ng∆∞·ªùi ch∆°i
        let eventMultiplier = 1; // H·ªá s·ªë tƒÉng event cells
        let lastWinTurn = 0; // L∆∞·ª£t cu·ªëi c√πng c√≥ ng∆∞·ªùi tr√∫ng th∆∞·ªüng
        let playerCellMap = new Map(); // Map t·ª´ cell index -> player index (cho ph√©p nhi·ªÅu cell c√πng player)
        const GRID_COLS = 15; // S·ªë c·ªôt c·ªßa grid
        const GRID_ROWS = 7; // S·ªë h√†ng c·ªßa grid
        const TOTAL_CELLS = GRID_COLS * GRID_ROWS; // T·ªïng s·ªë √¥ (105)
        let isLoadingData = false; // Flag ƒë·ªÉ tr√°nh l∆∞u khi ƒëang load
        let shouldMoveBackward = false; // Flag ƒë·ªÉ l√πi ·ªü l·∫ßn gieo x√≠ ng·∫ßu ti·∫øp theo

        // Kh·ªüi t·∫°o grid v·ªõi k√≠ch th∆∞·ªõc responsive
        function initGrid() {
            const gridContainer = document.getElementById('gridContainer');
            gridContainer.innerHTML = '';
            cells = [];

            // Thi·∫øt l·∫≠p grid template d·ª±a tr√™n GRID_COLS v√† GRID_ROWS
            // C·ªôt: 1 c·ªôt nh√£n h√†ng (30px) + GRID_COLS c·ªôt cells (1fr m·ªói c·ªôt)
            gridContainer.style.gridTemplateColumns = `30px repeat(${GRID_COLS}, 1fr)`;
            gridContainer.style.gridTemplateRows = `30px repeat(${GRID_ROWS}, 1fr) 30px`;

            // T·∫°o √¥ g√≥c tr√™n tr√°i (s·ªë 0)
            const cornerCell = document.createElement('div');
            cornerCell.className = 'grid-label';
            cornerCell.textContent = '0';
            cornerCell.style.gridColumn = '1';
            cornerCell.style.gridRow = '1';
            gridContainer.appendChild(cornerCell);

            // T·∫°o nh√£n c·ªôt (1 ƒë·∫øn GRID_COLS) - g√≥c ƒë√£ l√† 0 r·ªìi
            for (let col = 1; col <= GRID_COLS; col++) {
                const label = document.createElement('div');
                label.className = 'grid-label col';
                label.textContent = col;
                label.style.gridColumn = col + 1;
                label.style.gridRow = '1';
                gridContainer.appendChild(label);
            }

            // T·∫°o c√°c h√†ng ch·ª©a cells
            for (let row = 0; row < GRID_ROWS; row++) {
                // Nh√£n h√†ng (0 ƒë·∫øn GRID_ROWS-1)
                const rowLabel = document.createElement('div');
                rowLabel.className = 'grid-label row';
                rowLabel.textContent = row;
                rowLabel.style.gridColumn = '1';
                rowLabel.style.gridRow = row + 2;
                gridContainer.appendChild(rowLabel);

                // T·∫°o c√°c √¥ trong m·ªói h√†ng
                for (let col = 0; col < GRID_COLS; col++) {
                    const cellIndex = row * GRID_COLS + col;
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${cellIndex}`;
                    cell.dataset.index = cellIndex;
                    cell.dataset.cellNumber = cellIndex + 1;
                    cell.style.gridColumn = col + 2;
                    cell.style.gridRow = row + 2;
                    gridContainer.appendChild(cell);
                    cells.push(cell);
                }
            }
            
            // T·∫°o h√†ng cu·ªëi c√πng v·ªõi nh√£n s·ªë GRID_ROWS
            const lastRowLabel = document.createElement('div');
            lastRowLabel.className = 'grid-label row';
            lastRowLabel.textContent = GRID_ROWS;
            lastRowLabel.style.gridColumn = '1';
            lastRowLabel.style.gridRow = GRID_ROWS + 2;
            gridContainer.appendChild(lastRowLabel);
            
            // √î g√≥c d∆∞·ªõi ph·∫£i (s·ªë GRID_COLS) - kh√¥ng c·∫ßn v√¨ ƒë√£ c√≥ ·ªü h√†ng tr√™n
        }

        // T·∫°o √¢m thanh ƒë∆°n gi·∫£n
        function playSound(type) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                switch(type) {
                    case 'dice':
                        oscillator.frequency.value = 400;
                        oscillator.type = 'sine';
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    case 'win':
                        oscillator.frequency.value = 523.25; // C5
                        oscillator.type = 'sine';
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.5);
                        break;
                    case 'event':
                        oscillator.frequency.value = 300;
                        oscillator.type = 'square';
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                    case 'kill':
                        oscillator.frequency.value = 150;
                        oscillator.type = 'sawtooth';
                        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    case 'move':
                        // √Çm thanh t√°ch t√°ch khi di chuy·ªÉn (gi·ªëng g√µ ph√≠m c∆°)
                        oscillator.frequency.value = 800;
                        oscillator.type = 'square';
                        gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.05);
                        break;
                }
            } catch(e) {
                // N·∫øu kh√¥ng th·ªÉ t·∫°o audio context, b·ªè qua
            }
        }

        // Ph√¢n b·ªï ng∆∞·ªùi ch∆°i v√† event cells
        function distributePlayers(isInitial = false) {
            // L∆∞u l·∫°i event cells c≈© n·∫øu kh√¥ng ph·∫£i l·∫ßn ƒë·∫ßu
            const oldEventIndices = [...eventCells];
            const oldEventData = { ...eventData };
            
            // Reset t·∫•t c·∫£ cells (tr·ª´ event cells v√† c√°c √¥ ƒë√£ tr√∫ng th∆∞·ªüng n·∫øu kh√¥ng ph·∫£i l·∫ßn ƒë·∫ßu)
            cells.forEach((cell, idx) => {
                // Gi·ªØ nguy√™n c√°c √¥ ƒë√£ tr√∫ng th∆∞·ªüng
                if (cell.dataset.won === 'true') {
                    return; // Kh√¥ng reset √¥ ƒë√£ tr√∫ng th∆∞·ªüng
                }
                
                if (isInitial || !oldEventIndices.includes(idx)) {
                    cell.className = 'cell';
                    cell.textContent = '';
                    cell.dataset.type = '';
                    cell.dataset.eventType = '';
                    cell.dataset.tooltip = '';
                    cell.title = '';
                    cell.dataset.won = '';
                    // Gi·ªØ l·∫°i data-cell-number (s·ªë th·ª© t·ª± √¥)
                    if (!cell.dataset.cellNumber) {
                        cell.dataset.cellNumber = idx + 1;
                    }
                } else {
                    // ƒê·∫£m b·∫£o event cells gi·ªØ nguy√™n tooltip
                    if (oldEventData[idx]) {
                        cell.dataset.tooltip = oldEventData[idx].desc;
                        cell.title = oldEventData[idx].desc;
                    }
                }
            });

            // Ch·ªâ t·∫°o event cells m·ªõi n·∫øu l√† l·∫ßn ƒë·∫ßu
            if (isInitial) {
                eventCells = [];
                eventData = {};

                // T·∫°o event cells (tƒÉng t·∫ßn su·∫•t d·ª±a tr√™n t·ªïng s·ªë √¥)
                const baseEvents = Math.floor(Math.random() * (TOTAL_CELLS * 0.3)) + Math.floor(TOTAL_CELLS * 0.25);
                const numEvents = Math.min(Math.floor(baseEvents * eventMultiplier), Math.floor(TOTAL_CELLS * 0.5));
                const eventIndices = [];
                while (eventIndices.length < numEvents) {
                    const idx = Math.floor(Math.random() * TOTAL_CELLS);
                    if (!eventIndices.includes(idx) && idx !== 0) {
                        eventIndices.push(idx);
                    }
                }

                // ƒê·ªãnh nghƒ©a c√°c lo·∫°i event v·ªõi icon, m√¥ t·∫£ v√† category
                const movementEvents = [
                    { type: 'move_forward', icon: '‚¨ÜÔ∏è', desc: 'Ti·∫øn th√™m 1-5 √¥', category: 'movement' },
                    { type: 'move_backward', icon: '‚¨áÔ∏è', desc: 'L√πi 1-3 √¥', category: 'movement' },
                    { type: 'jump_row', icon: '‚¨áÔ∏è', desc: 'Nh·∫£y xu·ªëng h√†ng d·ªçc', category: 'movement' },
                    { type: 'jump_col', icon: '‚û°Ô∏è', desc: 'Nh·∫£y sang h√†ng ngang', category: 'movement' },
                    { type: 'go_back', icon: 'üîô', desc: 'ƒêi ng∆∞·ª£c v·ªÅ', category: 'movement' }
                ];
                
                // T·∫•n c√¥ng - tƒÉng g·∫•p ƒë√¥i t·∫ßn su·∫•t b·∫±ng c√°ch duplicate
                const attackEvents = [
                    { type: 'kill_random', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n', category: 'attack' },
                    { type: 'kill_forward', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t ph√≠a tr∆∞·ªõc', category: 'attack' },
                    { type: 'kill_backward', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t ph√≠a sau', category: 'attack' },
                    { type: 'bomb_row', icon: 'üí£', desc: 'Bom h√†ng ngang', category: 'attack' },
                    { type: 'bomb_col', icon: 'üí£', desc: 'Bom h√†ng d·ªçc', category: 'attack' },
                    { type: 'bomb_cross', icon: 'üí•', desc: 'Bom ch·ªØ th·∫≠p (ngang + d·ªçc)', category: 'attack' },
                    { type: 'bouncing_bomb', icon: 'üí£üí•', desc: 'Bom n·∫£y - n·ªï x l·∫ßn m·ªói 2-3 √¥', category: 'attack' },
                    // Duplicate ƒë·ªÉ tƒÉng g·∫•p ƒë√¥i t·∫ßn su·∫•t
                    { type: 'kill_random', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n', category: 'attack' },
                    { type: 'kill_forward', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t ph√≠a tr∆∞·ªõc', category: 'attack' },
                    { type: 'kill_backward', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t ph√≠a sau', category: 'attack' },
                    { type: 'bomb_row', icon: 'üí£', desc: 'Bom h√†ng ngang', category: 'attack' },
                    { type: 'bomb_col', icon: 'üí£', desc: 'Bom h√†ng d·ªçc', category: 'attack' },
                    { type: 'bomb_cross', icon: 'üí•', desc: 'Bom ch·ªØ th·∫≠p (ngang + d·ªçc)', category: 'attack' },
                    { type: 'bouncing_bomb', icon: 'üí£üí•', desc: 'Bom n·∫£y - n·ªï x l·∫ßn m·ªói 2-3 √¥', category: 'attack' }
                ];
                
                const defenseEvents = [
                    { type: 'shield', icon: 'üõ°Ô∏è', desc: 'T·∫°o khi√™n cho 1-3 ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n + th√™m √¥ khi√™n', category: 'defense' }
                ];
                
                // G·ªôp t·∫•t c·∫£ event types
                const eventTypes = [...movementEvents, ...attackEvents, ...defenseEvents];

                // T·∫°o 2 portal (tr∆∞·ªõc khi t·∫°o event cells kh√°c)
                portalPairs = [];
                const portalIndices = [];
                while (portalIndices.length < 2) {
                    const idx = Math.floor(Math.random() * TOTAL_CELLS);
                    if (!eventIndices.includes(idx) && idx !== 0 && !portalIndices.includes(idx)) {
                        portalIndices.push(idx);
                        eventIndices.push(idx); // Th√™m v√†o eventIndices ƒë·ªÉ kh√¥ng b·ªã tr√πng
                    }
                }
                portalPairs = [portalIndices[0], portalIndices[1]];

                eventIndices.forEach(idx => {
                    let eventInfo;
                    if (portalPairs.includes(idx)) {
                        // Portal
                        eventInfo = { type: 'portal', icon: 'üåÄ', desc: 'Portal - ƒêi t·∫Øt sang √¥ kia', category: 'movement' };
                    } else {
                        eventInfo = eventTypes[Math.floor(Math.random() * eventTypes.length)];
                    }
                    
                    cells[idx].className = `cell event ${eventInfo.category}`;
                    cells[idx].textContent = eventInfo.icon;
                    cells[idx].dataset.type = 'event';
                    cells[idx].dataset.eventType = eventInfo.type;
                    cells[idx].dataset.tooltip = eventInfo.desc;
                    cells[idx].title = eventInfo.desc;
                    // ƒê·∫£m b·∫£o c√≥ data-cell-number ƒë·ªÉ hi·ªÉn th·ªã s·ªë th·ª© t·ª±
                    cells[idx].dataset.cellNumber = idx + 1;
                    eventData[idx] = eventInfo;
                    eventCells.push(idx);
                });
            } else {
                // Gi·ªØ l·∫°i event cells c≈©
                eventCells = oldEventIndices;
                eventData = oldEventData;
            }
            
            // L·∫•y danh s√°ch event indices hi·ªán t·∫°i
            const eventIndices = eventCells;

            // Ph√¢n b·ªï ng∆∞·ªùi ch∆°i v√†o c√°c √¥ c√≤n l·∫°i (tr·ª´ √¥ 0, event cells, v√† c√°c √¥ ƒë√£ tr√∫ng th∆∞·ªüng)
            const availableCells = [];
            for (let i = 1; i < TOTAL_CELLS; i++) {
                if (!eventIndices.includes(i) && cells[i].dataset.won !== 'true') {
                    availableCells.push(i);
                }
            }

            // Ph√¢n b·ªï t·∫•t c·∫£ players (kh√¥ng lo·∫°i tr·ª´ ng∆∞·ªùi ƒë√£ tr√∫ng, v√¨ h·ªç v·∫´n c√≥ th·ªÉ xu·∫•t hi·ªán ·ªü √¥ kh√°c)
            const eligiblePlayerIndices = [];
            for (let i = 0; i < originalPlayers.length; i++) {
                eligiblePlayerIndices.push(i);
            }

            if (eligiblePlayerIndices.length === 0) {
                return; // Kh√¥ng c√≤n ng∆∞·ªùi ch∆°i n√†o
            }

            // T√≠nh s·ªë l∆∞·ª£ng player c·∫ßn ph√¢n b·ªï (t·ªâ l·ªá ban ƒë·∫ßu √≠t h∆°n)
            // T·ªâ l·ªá ban ƒë·∫ßu: 15% s·ªë √¥ tr·ªëng, t·ªëi thi·ªÉu b·∫±ng s·ªë ng∆∞·ªùi ch∆°i
            const minPlayerCells = Math.max(eligiblePlayerIndices.length, Math.floor(availableCells.length * 0.15));
            const targetPlayerCount = Math.min(
                Math.max(
                    Math.ceil(eligiblePlayerIndices.length * playerRepeatMultiplier),
                    minPlayerCells
                ),
                availableCells.length
            );

            const playerIndices = [];
            const usedCells = new Set();
            
            // Ph√¢n b·ªï player v·ªõi kh·∫£ nƒÉng l·∫∑p l·∫°i
            const availableCellsCopy = [...availableCells];
            for (let i = 0; i < targetPlayerCount && availableCellsCopy.length > 0; i++) {
                const randomPlayerIdx = eligiblePlayerIndices[Math.floor(Math.random() * eligiblePlayerIndices.length)];
                const randomCellIdx = Math.floor(Math.random() * availableCellsCopy.length);
                const cellIdx = availableCellsCopy[randomCellIdx];
                
                if (!usedCells.has(cellIdx)) {
                    playerIndices.push({ cellIdx, playerIdx: randomPlayerIdx });
                    usedCells.add(cellIdx);
                    availableCellsCopy.splice(randomCellIdx, 1);
                }
            }

            // L∆∞u mapping gi·ªØa cell index v√† player index (cho ph√©p nhi·ªÅu cell c√πng player)
            playerCellMap.clear();
            playerIndices.forEach(({ cellIdx, playerIdx }) => {
                // Ki·ªÉm tra xem player n√†y c√≥ b·ªã ch·∫øt ·ªü cell n√†y kh√¥ng (m·ªói cell ƒë·ªôc l·∫≠p)
                const cellKey = `${cellIdx}_${playerIdx}`;
                const isDead = deadPlayers.has(cellKey) || deadPlayers.has(playerIdx);
                const isWon = cells[cellIdx].dataset.won === 'true';
                
                // N·∫øu √¥ ƒë√£ tr√∫ng th∆∞·ªüng, gi·ªØ nguy√™n class winner
                if (isWon) {
                    cells[cellIdx].classList.add('player', 'winner');
                } else {
                    cells[cellIdx].className = isDead ? 'cell player dead' : 'cell player';
                }
                
                // Hi·ªÉn th·ªã ƒë·∫ßy ƒë·ªß t√™n, cho ph√©p xu·ªëng h√†ng
                let playerName = originalPlayers[playerIdx];
                cells[cellIdx].textContent = playerName;
                cells[cellIdx].title = originalPlayers[playerIdx];
                cells[cellIdx].dataset.type = 'player';
                cells[cellIdx].dataset.playerIndex = playerIdx;
                cells[cellIdx].dataset.cellKey = cellKey; // L∆∞u key ƒë·ªÉ x·ª≠ l√Ω ƒë·ªôc l·∫≠p
                playerCellMap.set(cellIdx, playerIdx);
            });
        }


        // T·ª± ƒë·ªông ƒë√°nh s·ªë danh s√°ch trong textarea
        function autoNumberList(textarea, preserveCursor = false) {
            const cursorPos = textarea.selectionStart;
            const lines = textarea.value.split('\n');
            let newCursorPos = cursorPos;
            
            const numberedLines = lines.map((line, index) => {
                const trimmed = line.trim();
                if (!trimmed) return '';
                
                // Ki·ªÉm tra xem ƒë√£ c√≥ s·ªë ch∆∞a
                const match = trimmed.match(/^(\d+)\.\s*(.*)$/);
                if (match) {
                    const oldNum = match[1];
                    const content = match[2];
                    const newNum = index + 1;
                    if (oldNum !== String(newNum)) {
                        // ƒêi·ªÅu ch·ªânh v·ªã tr√≠ con tr·ªè n·∫øu c·∫ßn
                        if (preserveCursor && cursorPos > textarea.value.indexOf(line)) {
                            const lineStart = textarea.value.indexOf(line);
                            const offset = String(newNum).length - oldNum.length;
                            if (cursorPos >= lineStart && cursorPos <= lineStart + line.length) {
                                newCursorPos += offset;
                            }
                        }
                        return `${newNum}. ${content}`;
                    }
                    return trimmed;
                }
                return `${index + 1}. ${trimmed}`;
            });
            
            textarea.value = numberedLines.join('\n');
            if (preserveCursor) {
                textarea.setSelectionRange(newCursorPos, newCursorPos);
            }
        }

        // Ki·ªÉm tra v√† enable/disable n√∫t b·∫Øt ƒë·∫ßu
        function checkStartButton() {
            const playersInput = document.getElementById('playersInput').value.trim();
            const prizesInput = document.getElementById('prizesInput').value.trim();
            const startBtn = document.getElementById('startBtn');

            if (playersInput && prizesInput) {
                startBtn.disabled = false;
                startBtn.style.opacity = '1';
                startBtn.style.cursor = 'pointer';
            } else {
                startBtn.disabled = true;
                startBtn.style.opacity = '0.5';
                startBtn.style.cursor = 'not-allowed';
            }
        }

        // X·ª≠ l√Ω upload ·∫£nh
        document.getElementById('avatarUpload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    avatarImage = e.target.result;
                    const avatarPreview = document.getElementById('avatarPreview');
                    avatarPreview.src = avatarImage;
                    avatarPreview.style.display = 'block';
                    saveGameData(); // L∆∞u d·ªØ li·ªáu khi upload avatar
                };
                reader.readAsDataURL(file);
            } else {
                avatarImage = null;
                const avatarPreview = document.getElementById('avatarPreview');
                avatarPreview.style.display = 'none';
                saveGameData(); // L∆∞u d·ªØ li·ªáu khi x√≥a avatar
            }
        });

        // L·∫Øng nghe thay ƒë·ªïi input
        document.getElementById('playersInput').addEventListener('input', function() {
            checkStartButton();
            saveGameData();
        });
        document.getElementById('playersInput').addEventListener('blur', function() {
            autoNumberList(this, false);
            saveGameData();
        });
        
        document.getElementById('prizesInput').addEventListener('input', function() {
            checkStartButton();
            saveGameData();
        });
        document.getElementById('prizesInput').addEventListener('blur', function() {
            autoNumberList(this, false);
            saveGameData();
        });

        // B·∫Øt ƒë·∫ßu game
        document.getElementById('startBtn').addEventListener('click', function() {
            let playersInput = document.getElementById('playersInput').value.trim();
            let prizesInput = document.getElementById('prizesInput').value.trim();

            // Lo·∫°i b·ªè s·ªë th·ª© t·ª± v√† d·∫•u sao n·∫øu c√≥
            originalPlayers = playersInput.split('\n')
                .filter(p => p.trim())
                .map(p => p.replace(/^\d+\.\s*/, '').replace(/‚≠ê\s*/, '').trim());
            originalPrizes = prizesInput.split('\n')
                .filter(p => p.trim())
                .map(p => p.replace(/^\d+\.\s*/, '').trim());
            players = [...originalPlayers];
            prizes = [...originalPrizes];

            if (originalPlayers.length === 0 || originalPrizes.length === 0) {
                alert('Vui l√≤ng nh·∫≠p √≠t nh·∫•t 1 ng∆∞·ªùi ch∆°i v√† 1 ph·∫ßn th∆∞·ªüng!');
                return;
            }

            currentPosition = 0;
            gameStarted = true;
            deadPlayers = new Set();
            playerShields = {};
            playerWinners = new Set();
            gameHistory = [];
            turnCount = 0;
            roundCount = 0;
            playerRepeatMultiplier = 1;
            eventMultiplier = 1;
            lastWinTurn = 0;
            playerCellMap = new Map();
            document.getElementById('historyContainer').innerHTML = '';
            initGrid(); // Kh·ªüi t·∫°o l·∫°i grid v·ªõi k√≠ch th∆∞·ªõc m·ªõi
            distributePlayers(true);
            createGamePiece();
            
            // Hi·ªÉn th·ªã n√∫t gieo x√∫c x·∫Øc v√† ·∫©n n√∫t b·∫Øt ƒë·∫ßu
            document.getElementById('diceBtn').style.display = 'block';
            document.getElementById('startBtn').style.display = 'none';
            
            addToHistory('üéÆ B·∫Øt ƒë·∫ßu game!', false);
            saveGameData(); // L∆∞u d·ªØ li·ªáu khi b·∫Øt ƒë·∫ßu game
        });

        // N√∫t gieo x√∫c x·∫Øc th·ªß c√¥ng
        document.getElementById('diceBtn').addEventListener('click', function() {
            if (!isMoving && prizes.length > 0) {
                this.disabled = true;
                rollDice();
            }
        });

        // T·∫°o qu√¢n c·ªù
        function createGamePiece() {
            // X√≥a qu√¢n c·ªù c≈© n·∫øu c√≥
            if (gamePiece) {
                gamePiece.remove();
            }

            gamePiece = document.createElement('div');
            gamePiece.className = 'game-piece';
            
            if (avatarImage) {
                const img = document.createElement('img');
                img.src = avatarImage;
                gamePiece.appendChild(img);
            } else {
                // S·ª≠ d·ª•ng ·∫£nh m·∫∑c ƒë·ªãnh ho·∫∑c icon
                const img = document.createElement('img');
                img.src = 'https://media.nguyez.com/IMG/AVT-NguyeZGaming.png';
                img.onerror = function() {
                    // N·∫øu ·∫£nh kh√¥ng load ƒë∆∞·ª£c, d√πng emoji
                    this.style.display = 'none';
                    gamePiece.textContent = 'üéÆ';
                    gamePiece.style.fontSize = '40px';
                };
                gamePiece.appendChild(img);
            }

            const firstCell = cells[0];
            firstCell.appendChild(gamePiece);
            firstCell.classList.add('current');
        }

        // X√∫c x·∫Øc
        function rollDice() {
            const diceContainer = document.getElementById('diceContainer');
            const diceResult = document.getElementById('diceResult');
            const diceBtn = document.getElementById('diceBtn');
            
            diceContainer.classList.add('active');
            diceResult.textContent = 'ƒêang x√∫c x·∫Øc...';

            // Animation x√∫c x·∫Øc
            let rollCount = 0;
            const maxRolls = 15;
            const rollInterval = setInterval(() => {
                rollCount++;
                const randomValue = Math.floor(Math.random() * 21) + 1;
                diceResult.textContent = `üé≤ ${randomValue}`;
                
                if (rollCount >= maxRolls) {
                    clearInterval(rollInterval);
                    const diceValue = Math.floor(Math.random() * 21) + 1; // 1-21
                    diceResult.textContent = `K·∫øt qu·∫£: ${diceValue}`;
                    
                    // Th√™m v√†o l·ªãch s·ª≠ (tƒÉng l∆∞·ª£t)
                    addToHistory(`üé≤ Gieo x√∫c x·∫Øc: ${diceValue}`, true);
                    playSound('dice');
                    
                    // C·∫≠p nh·∫≠t countdown
                    updateLuckyCountdown();
                    
                    // Ki·ªÉm tra v√† tƒÉng c∆° h·ªôi sau m·ªói 7 l∆∞·ª£t gieo x√≠ ng·∫ßu
                    if (turnCount > 0 && turnCount % 7 === 0) {
                        // Ch·ªçn ng·∫´u nhi√™n 25% ng∆∞·ªùi ch∆°i (l√†m tr√≤n l√™n) v√† th√™m v√†o c√°c √¥ tr·ªëng
                        const eligiblePlayers = [];
                        for (let i = 0; i < originalPlayers.length; i++) {
                            eligiblePlayers.push(i);
                        }
                        
                        if (eligiblePlayers.length > 0) {
                            const luckyCount = Math.ceil(eligiblePlayers.length * 0.25);
                            const luckyPlayers = [];
                            const shuffled = [...eligiblePlayers].sort(() => Math.random() - 0.5);
                            
                            for (let i = 0; i < luckyCount && i < shuffled.length; i++) {
                                luckyPlayers.push(shuffled[i]);
                            }
                            
                            // T√¨m c√°c √¥ tr·ªëng ƒë·ªÉ th√™m ng∆∞·ªùi ch∆°i may m·∫Øn (kh√¥ng c√≥ player, event, ho·∫∑c ƒë√£ tr√∫ng th∆∞·ªüng)
                            const emptyCells = [];
                            for (let i = 1; i < TOTAL_CELLS; i++) {
                                const cellType = cells[i].dataset.type;
                                if ((cellType === '' || cellType === 'empty') && 
                                    !eventCells.includes(i) && 
                                    cells[i].dataset.won !== 'true' &&
                                    cellType !== 'player') {
                                    emptyCells.push(i);
                                }
                            }
                            
                            // Th√™m ng∆∞·ªùi ch∆°i may m·∫Øn v√†o c√°c √¥ tr·ªëng
                            let addedCount = 0;
                            const shuffledEmptyCells = [...emptyCells].sort(() => Math.random() - 0.5);
                            
                            for (let i = 0; i < Math.min(luckyPlayers.length, shuffledEmptyCells.length); i++) {
                                const cellIdx = shuffledEmptyCells[i];
                                const playerIdx = luckyPlayers[i];
                                const cellKey = `${cellIdx}_${playerIdx}`;
                                
                                // Ki·ªÉm tra l·∫°i xem cell n√†y c√≥ tr·ªëng kh√¥ng
                                const cellType = cells[cellIdx].dataset.type;
                                if ((cellType === '' || cellType === 'empty') && 
                                    !eventCells.includes(cellIdx) && 
                                    cells[cellIdx].dataset.won !== 'true') {
                                    cells[cellIdx].className = 'cell player';
                                    let playerName = originalPlayers[playerIdx];
                                    cells[cellIdx].textContent = playerName;
                                    cells[cellIdx].title = originalPlayers[playerIdx];
                                    cells[cellIdx].dataset.type = 'player';
                                    cells[cellIdx].dataset.playerIndex = playerIdx;
                                    cells[cellIdx].dataset.cellKey = cellKey;
                                    playerCellMap.set(cellIdx, playerIdx);
                                    addedCount++;
                                }
                            }
                            
                            if (addedCount > 0) {
                                // Ghi v√†o l·ªãch s·ª≠ v·ªõi th√¥ng tin chi ti·∫øt
                                const addedPlayers = [];
                                for (let i = 0; i < addedCount; i++) {
                                    const cellIdx = shuffledEmptyCells[i];
                                    const playerIdx = luckyPlayers[i];
                                    const playerName = originalPlayers[playerIdx];
                                    const cellNumber = cellIdx + 1;
                                    addedPlayers.push(`${playerName} (√¥ ${cellNumber})`);
                                }
                                const luckyMessage = `üçÄ Sau ${turnCount} l∆∞·ª£t gieo x√≠ ng·∫ßu! ${addedCount} ng∆∞·ªùi ch∆°i may m·∫Øn ƒë∆∞·ª£c th√™m v√†o: ${addedPlayers.join(', ')}`;
                                showEvent(luckyMessage);
                                addToHistory(luckyMessage, false);
                                updateLuckyCountdown(); // C·∫≠p nh·∫≠t countdown sau khi th√™m
                                saveGameData();
                            }
                        }
                    }
                    
                    setTimeout(() => {
                        diceContainer.classList.remove('active');
                        isMoving = true;
                        // Ki·ªÉm tra n·∫øu c·∫ßn l√πi
                        if (shouldMoveBackward) {
                            movePiece(-diceValue);
                            shouldMoveBackward = false; // Reset flag sau khi l√πi
                        } else {
                            movePiece(diceValue);
                        }
                    }, 1800);
                }
            }, 80);
        }

        // H√†m t√≠nh v·ªã tr√≠ v·ªõi v√≤ng l·∫∑p (0 ƒë·∫øn TOTAL_CELLS-1)
        function normalizePosition(pos) {
            if (pos >= TOTAL_CELLS) {
                return pos % TOTAL_CELLS;
            } else if (pos < 0) {
                return ((pos % TOTAL_CELLS) + TOTAL_CELLS) % TOTAL_CELLS;
            }
            return pos;
        }

        // Di chuy·ªÉn qu√¢n c·ªù
        function movePiece(steps) {
            const startPosition = currentPosition;
            const totalSteps = Math.abs(steps);
            const direction = steps > 0 ? 1 : -1;
            
            // T√≠nh v·ªã tr√≠ ƒë√≠ch v·ªõi v√≤ng l·∫∑p
            let targetPosition = normalizePosition(startPosition + steps);
            
            let stepsTaken = 0;

            // Di chuy·ªÉn ƒë·∫øn t·ª´ng √¥
            const moveInterval = setInterval(() => {
                stepsTaken++;
                let nextPos = startPosition + (stepsTaken * direction);
                nextPos = normalizePosition(nextPos);
                
                if (stepsTaken <= totalSteps) {
                    // X√≥a class current kh·ªèi √¥ c≈©
                    if (stepsTaken === 1) {
                        cells[startPosition].classList.remove('current');
                        cells[startPosition].classList.add('visited');
                    } else {
                        let prevPos = startPosition + ((stepsTaken - 1) * direction);
                        prevPos = normalizePosition(prevPos);
                        cells[prevPos].classList.remove('current');
                    }
                    
                    // Di chuy·ªÉn qu√¢n c·ªù
                    if (gamePiece) {
                        const targetCell = cells[nextPos];
                        if (gamePiece.parentNode !== targetCell) {
                            // X√≥a kh·ªèi √¥ c≈©
                            if (gamePiece.parentNode) {
                                gamePiece.parentNode.removeChild(gamePiece);
                            }
                            // Th√™m v√†o √¥ m·ªõi
                            targetCell.appendChild(gamePiece);
                        }
                        // ƒê·∫£m b·∫£o v·ªã tr√≠ ƒë√∫ng
                        gamePiece.style.top = '50%';
                        gamePiece.style.left = '50%';
                        
                        // Ph√°t √¢m thanh khi di chuy·ªÉn
                        playSound('move');
                    }
                    
                    cells[nextPos].classList.add('current');
                    cells[nextPos].classList.add('visited');

                    // Scroll ƒë·∫øn √¥ hi·ªán t·∫°i
                    cells[nextPos].scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // C·∫≠p nh·∫≠t v·ªã tr√≠ hi·ªán t·∫°i
                    currentPosition = nextPos;
                    
                    // Ki·ªÉm tra ƒë√£ ƒë·∫øn ƒë√≠ch ch∆∞a
                    if (stepsTaken === totalSteps) {
                        clearInterval(moveInterval);
                        setTimeout(() => {
                            handleCellLanding(targetPosition);
                        }, 300);
                    }
                } else {
                    clearInterval(moveInterval);
                    setTimeout(() => {
                        handleCellLanding(currentPosition);
                    }, 300);
                }
            }, 200);
        }

        // X·ª≠ l√Ω khi qu√¢n c·ªù d·ª´ng ·ªü m·ªôt √¥
        function handleCellLanding(position) {
            const cell = cells[position];
            const cellType = cell.dataset.type;
            const diceBtn = document.getElementById('diceBtn');

            // Qu√¢n c·ªù c√≥ th·ªÉ ƒëi qua √¥ player ƒë√£ ch·∫øt, ch·ªâ x·ª≠ l√Ω n·∫øu l√† player c√≤n s·ªëng
            if (cellType === 'player' && !cell.classList.contains('dead')) {
                const playerIndex = parseInt(cell.dataset.playerIndex);
                const existingCellKey = cell.dataset.cellKey;
                const isDead = deadPlayers.has(existingCellKey) || deadPlayers.has(playerIndex);
                const isWon = cell.dataset.won === 'true';
                
                if (!isDead && !isWon && prizes.length > 0) {
                    const player = originalPlayers[playerIndex];
                    const prize = prizes.shift();

                    // ƒê√°nh d·∫•u ng∆∞·ªùi ch∆°i ƒë√£ tr√∫ng th∆∞·ªüng (ch·ªâ ƒë√°nh d·∫•u cell n√†y, kh√¥ng x√≥a)
                    const wonCellKey = `${position}_${playerIndex}`;
                    playerWinners.add(wonCellKey); // L∆∞u cellKey ƒë·ªÉ ƒë√°nh d·∫•u cell c·ª• th·ªÉ ƒë√£ tr√∫ng
                    lastWinTurn = turnCount;
                    playerRepeatMultiplier = 1; // Reset multiplier khi c√≥ ng∆∞·ªùi tr√∫ng
                    eventMultiplier = 1;

                    // ƒê√°nh d·∫•u √¥ n√†y l√† winner nh∆∞ng v·∫´n gi·ªØ t√™n v√† class player
                    cell.classList.add('winner');
                    cell.dataset.won = 'true'; // ƒê√°nh d·∫•u √¥ n√†y ƒë√£ tr√∫ng th∆∞·ªüng

                    // Th√™m v√†o k·∫øt qu·∫£
                    addResult(player, prize, playerIndex);
                    playSound('win');

                    // C·∫≠p nh·∫≠t textarea (ƒë√°nh d·∫•u sao nh∆∞ng kh√¥ng x√≥a)
                    updateTextareaAfterWin();

                    // K√≠ch ho·∫°t l·∫°i n√∫t gieo x√∫c x·∫Øc
                    isMoving = false;
                    diceBtn.disabled = false;

                    // Ki·ªÉm tra ƒëi·ªÅu ki·ªán ti·∫øp t·ª•c
                    if (prizes.length === 0) {
                        setTimeout(() => {
                            showEvent('üéâ ƒê√£ trao h·∫øt ph·∫ßn th∆∞·ªüng!');
                            diceBtn.style.display = 'none';
                        }, 2000);
                    }
                } else if (cell.dataset.won === 'true') {
                    // √î n√†y ƒë√£ tr√∫ng th∆∞·ªüng r·ªìi, kh√¥ng trao th∆∞·ªüng n·ªØa
                    isMoving = false;
                    diceBtn.disabled = false;
                } else {
                    isMoving = false;
                    diceBtn.disabled = false;
                }
            } else if (cellType === 'event') {
                // X·ª≠ l√Ω event
                handleEvent(position);
            } else {
                // √î tr·ªëng ho·∫∑c √¥ player ƒë√£ ch·∫øt
                isMoving = false;
                diceBtn.disabled = false;
                
                // Ki·ªÉm tra n·∫øu t·∫•t c·∫£ ng∆∞·ªùi ch∆°i ƒë√£ ch·∫øt
                checkAndRevivePlayers();
                
                if (prizes.length === 0) {
                    showEvent('üéâ ƒê√£ trao h·∫øt ph·∫ßn th∆∞·ªüng!');
                    diceBtn.style.display = 'none';
                }
            }
        }

        // Ki·ªÉm tra v√† h·ªìi sinh ng∆∞·ªùi ch∆°i n·∫øu t·∫•t c·∫£ ƒë√£ ch·∫øt
        function checkAndRevivePlayers() {
            // ƒê·∫øm s·ªë ng∆∞·ªùi ch∆°i c√≤n s·ªëng
            let aliveCount = 0;
            for (let i = 0; i < cells.length; i++) {
                if (cells[i].dataset.type === 'player' && !cells[i].classList.contains('dead')) {
                    const pIdx = parseInt(cells[i].dataset.playerIndex);
                    const cellKey = cells[i].dataset.cellKey;
                    if (!deadPlayers.has(cellKey) && !deadPlayers.has(pIdx) && !playerWinners.has(pIdx)) {
                        aliveCount++;
                    }
                }
            }

            if (aliveCount === 0 && prizes.length > 0) {
                // H·ªìi sinh ng·∫´u nhi√™n (tr·ª´ ng∆∞·ªùi ƒë√£ tr√∫ng)
                const eligiblePlayers = [];
                for (let i = 0; i < originalPlayers.length; i++) {
                    if (!playerWinners.has(i)) {
                        eligiblePlayers.push(i);
                    }
                }

                if (eligiblePlayers.length > 0) {
                    // X√≥a t·∫•t c·∫£ dead markers
                    deadPlayers.clear();
                    
                    // TƒÉng event cells v√† player repeat
                    eventMultiplier = Math.min(eventMultiplier + 0.5, 2);
                    playerRepeatMultiplier = Math.min(playerRepeatMultiplier + 1, 5);
                    
                    // X√≥a event cells c≈© v√† t·∫°o l·∫°i
                    eventCells = [];
                    eventData = {};
                    
                    // T·∫°o l·∫°i event cells v·ªõi multiplier m·ªõi
                    const baseEvents = Math.floor(Math.random() * (TOTAL_CELLS * 0.3)) + Math.floor(TOTAL_CELLS * 0.25);
                    const numEvents = Math.min(Math.floor(baseEvents * eventMultiplier), Math.floor(TOTAL_CELLS * 0.5));
                    const newEventIndices = [];
                    while (newEventIndices.length < numEvents) {
                        const idx = Math.floor(Math.random() * TOTAL_CELLS);
                        if (!newEventIndices.includes(idx) && idx !== 0) {
                            newEventIndices.push(idx);
                        }
                    }
                    
                    // ƒê·ªãnh nghƒ©a c√°c lo·∫°i event (tƒÉng g·∫•p ƒë√¥i t·∫ßn su·∫•t attack)
                    const movementEvents = [
                        { type: 'move_forward', icon: '‚¨ÜÔ∏è', desc: 'Ti·∫øn th√™m 1-5 √¥', category: 'movement' },
                        { type: 'move_backward', icon: '‚¨áÔ∏è', desc: 'L√πi 1-3 √¥', category: 'movement' },
                        { type: 'jump_row', icon: '‚¨áÔ∏è', desc: 'Nh·∫£y xu·ªëng h√†ng d·ªçc', category: 'movement' },
                        { type: 'jump_col', icon: '‚û°Ô∏è', desc: 'Nh·∫£y sang h√†ng ngang', category: 'movement' },
                        { type: 'go_back', icon: 'üîô', desc: 'ƒêi ng∆∞·ª£c v·ªÅ', category: 'movement' }
                    ];
                    
                    const attackEvents = [
                        { type: 'kill_random', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n', category: 'attack' },
                        { type: 'kill_forward', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t ph√≠a tr∆∞·ªõc', category: 'attack' },
                        { type: 'kill_backward', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t ph√≠a sau', category: 'attack' },
                        { type: 'bomb_row', icon: 'üí£', desc: 'Bom h√†ng ngang', category: 'attack' },
                        { type: 'bomb_col', icon: 'üí£', desc: 'Bom h√†ng d·ªçc', category: 'attack' },
                        { type: 'bomb_cross', icon: 'üí•', desc: 'Bom ch·ªØ th·∫≠p (ngang + d·ªçc)', category: 'attack' },
                        { type: 'bouncing_bomb', icon: 'üí£üí•', desc: 'Bom n·∫£y - n·ªï x l·∫ßn m·ªói 2-3 √¥', category: 'attack' },
                        // Duplicate ƒë·ªÉ tƒÉng g·∫•p ƒë√¥i t·∫ßn su·∫•t
                        { type: 'kill_random', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n', category: 'attack' },
                        { type: 'kill_forward', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t ph√≠a tr∆∞·ªõc', category: 'attack' },
                        { type: 'kill_backward', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t ph√≠a sau', category: 'attack' },
                        { type: 'bomb_row', icon: 'üí£', desc: 'Bom h√†ng ngang', category: 'attack' },
                        { type: 'bomb_col', icon: 'üí£', desc: 'Bom h√†ng d·ªçc', category: 'attack' },
                        { type: 'bomb_cross', icon: 'üí•', desc: 'Bom ch·ªØ th·∫≠p (ngang + d·ªçc)', category: 'attack' },
                        { type: 'bouncing_bomb', icon: 'üí£üí•', desc: 'Bom n·∫£y - n·ªï x l·∫ßn m·ªói 2-3 √¥', category: 'attack' }
                    ];
                    
                    const defenseEvents = [
                        { type: 'shield', icon: 'üõ°Ô∏è', desc: 'T·∫°o khi√™n cho 1-3 ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n + th√™m √¥ khi√™n', category: 'defense' }
                    ];
                    
                    const eventTypes = [...movementEvents, ...attackEvents, ...defenseEvents];
                    
                    // T·∫°o 2 portal
                    portalPairs = [];
                    const portalIndices = [];
                    while (portalIndices.length < 2) {
                        const idx = Math.floor(Math.random() * TOTAL_CELLS);
                        if (!newEventIndices.includes(idx) && idx !== 0 && !portalIndices.includes(idx)) {
                            portalIndices.push(idx);
                            newEventIndices.push(idx);
                        }
                    }
                    portalPairs = [portalIndices[0], portalIndices[1]];
                    
                    // T·∫°o event cells
                    newEventIndices.forEach(idx => {
                        let eventInfo;
                        if (portalPairs.includes(idx)) {
                            eventInfo = { type: 'portal', icon: 'üåÄ', desc: 'Portal - ƒêi t·∫Øt sang √¥ kia', category: 'movement' };
                        } else {
                            eventInfo = eventTypes[Math.floor(Math.random() * eventTypes.length)];
                        }
                        
                        cells[idx].className = `cell event ${eventInfo.category}`;
                        cells[idx].textContent = eventInfo.icon;
                        cells[idx].dataset.type = 'event';
                        cells[idx].dataset.eventType = eventInfo.type;
                        cells[idx].dataset.tooltip = eventInfo.desc;
                        cells[idx].title = eventInfo.desc;
                        // ƒê·∫£m b·∫£o c√≥ data-cell-number ƒë·ªÉ hi·ªÉn th·ªã s·ªë th·ª© t·ª±
                        cells[idx].dataset.cellNumber = idx + 1;
                        eventData[idx] = eventInfo;
                        eventCells.push(idx);
                    });
                    
                    // Ph√¢n b·ªï l·∫°i players
                    const savedPosition = currentPosition;
                    distributePlayers(false);
                    currentPosition = savedPosition;
                    
                    // ƒê·∫£m b·∫£o qu√¢n c·ªù v·∫´n ·ªü v·ªã tr√≠ hi·ªán t·∫°i
                    if (gamePiece && gamePiece.parentNode) {
                        gamePiece.parentNode.removeChild(gamePiece);
                    }
                    if (cells[currentPosition]) {
                        cells[currentPosition].appendChild(gamePiece);
                        cells[currentPosition].classList.add('current');
                    }
                    
                    showEvent('üîÑ T·∫•t c·∫£ ng∆∞·ªùi ch∆°i ƒë√£ h·ªìi sinh! C∆° h·ªôi tƒÉng l√™n!');
                    playSound('event');
                }
            }
        }

        // C·∫≠p nh·∫≠t textarea sau khi c√≥ ng∆∞·ªùi tr√∫ng th∆∞·ªüng
        function updateTextareaAfterWin() {
            // C·∫≠p nh·∫≠t danh s√°ch ng∆∞·ªùi ch∆°i - ƒë√°nh d·∫•u sao cho ng∆∞·ªùi ƒë√£ tr√∫ng nh∆∞ng kh√¥ng x√≥a
            const playersTextarea = document.getElementById('playersInput');
            const lines = playersTextarea.value.split('\n');
            const updatedLines = lines.map((line, index) => {
                const trimmed = line.trim();
                if (!trimmed) return '';
                
                // Lo·∫°i b·ªè s·ªë th·ª© t·ª± v√† d·∫•u sao n·∫øu c√≥
                const cleanLine = trimmed.replace(/^\d+\.\s*/, '').replace(/‚≠ê\s*/, '').trim();
                const playerIndex = originalPlayers.indexOf(cleanLine);
                
                // Ki·ªÉm tra xem player n√†y c√≥ cell n√†o ƒë√£ tr√∫ng th∆∞·ªüng kh√¥ng
                let hasWon = false;
                if (playerIndex >= 0) {
                    for (let i = 0; i < cells.length; i++) {
                        if (cells[i].dataset.type === 'player' && 
                            parseInt(cells[i].dataset.playerIndex) === playerIndex &&
                            cells[i].dataset.won === 'true') {
                            hasWon = true;
                            break;
                        }
                    }
                }
                
                // Gi·ªØ nguy√™n s·ªë th·ª© t·ª±, th√™m d·∫•u sao n·∫øu ƒë√£ tr√∫ng
                const match = trimmed.match(/^(\d+)\.\s*(.*)$/);
                if (match) {
                    const num = match[1];
                    const content = match[2].replace(/‚≠ê\s*/, '').trim();
                    return hasWon ? `${num}. ‚≠ê ${content}` : `${num}. ${content}`;
                }
                return hasWon ? `‚≠ê ${trimmed}` : trimmed;
            });
            playersTextarea.value = updatedLines.join('\n');

            // C·∫≠p nh·∫≠t danh s√°ch ph·∫ßn th∆∞·ªüng
            const prizesTextarea = document.getElementById('prizesInput');
            prizesTextarea.value = prizes.map((p, i) => `${i + 1}. ${p}`).join('\n');
            
            saveGameData(); // L∆∞u d·ªØ li·ªáu sau khi c·∫≠p nh·∫≠t
        }

        // Th√™m v√†o l·ªãch s·ª≠
        function addToHistory(message, incrementTurn = false) {
            if (incrementTurn) {
                turnCount++;
            }
            const historyContainer = document.getElementById('historyContainer');
            const historyItem = document.createElement('div');
            historyItem.className = 'history-item';
            historyItem.textContent = turnCount > 0 ? `L∆∞·ª£t ${turnCount}: ${message}` : message;
            historyContainer.appendChild(historyItem);
            historyContainer.scrollTop = historyContainer.scrollHeight;
            gameHistory.push({ turn: turnCount, message: message });
            saveGameData(); // L∆∞u d·ªØ li·ªáu khi c√≥ l·ªãch s·ª≠ m·ªõi
        }

        // Hi·ªÉn th·ªã s·ª± ki·ªán
        function showEvent(message) {
            const eventDisplay = document.getElementById('eventDisplay');
            const eventText = document.getElementById('eventText');
            eventText.textContent = message;
            eventDisplay.classList.add('active');
            
            // Th√™m v√†o l·ªãch s·ª≠
            addToHistory(message);
            
            // T·ª± ƒë·ªông ·∫©n sau 5 gi√¢y
            setTimeout(() => {
                eventDisplay.classList.remove('active');
            }, 5000);
        }

        // X·ª≠ l√Ω event cells
        function handleEvent(position) {
            const eventType = cells[position].dataset.eventType;
            const eventInfo = eventData[position];
            const diceBtn = document.getElementById('diceBtn');
            let message = '';

            switch (eventType) {
                // === DI CHUY·ªÇN ===
                case 'move_forward':
                    const forwardSteps = Math.floor(Math.random() * 5) + 1;
                    message = `‚¨ÜÔ∏è ${eventInfo.desc} (${forwardSteps} √¥)`;
                    showEvent(message);
                    setTimeout(() => {
                        isMoving = true;
                        movePiece(forwardSteps);
                    }, 1500);
                    return;

                case 'move_backward':
                    // ƒê√°nh d·∫•u s·∫Ω l√πi ·ªü l·∫ßn gieo x√≠ ng·∫ßu ti·∫øp theo
                    shouldMoveBackward = true;
                    message = `‚¨áÔ∏è ${eventInfo.desc} - S·∫Ω l√πi ·ªü l·∫ßn gieo x√≠ ng·∫ßu ti·∫øp theo!`;
                    showEvent(message);
                    setTimeout(() => {
                        isMoving = false;
                        diceBtn.disabled = false;
                    }, 1500);
                    return;

                case 'jump_row':
                    // Nh·∫£y xu·ªëng h√†ng d·ªçc (GRID_COLS √¥)
                    message = `‚¨áÔ∏è ${eventInfo.desc}`;
                    showEvent(message);
                    setTimeout(() => {
                        isMoving = true;
                        movePiece(GRID_COLS);
                    }, 1500);
                    return;

                case 'jump_col':
                    // Nh·∫£y sang h√†ng ngang (1 √¥ sang ph·∫£i)
                    message = `‚û°Ô∏è ${eventInfo.desc}`;
                    showEvent(message);
                    setTimeout(() => {
                        isMoving = true;
                        movePiece(1);
                    }, 1500);
                    return;

                case 'go_back':
                    // ƒêi ng∆∞·ª£c v·ªÅ
                    message = `üîô ${eventInfo.desc}`;
                    showEvent(message);
                    setTimeout(() => {
                        isMoving = true;
                        // T√≠nh s·ªë b∆∞·ªõc ƒë·ªÉ quay v·ªÅ √¥ 0 (ho·∫∑c g·∫ßn nh·∫•t)
                        const backSteps = currentPosition;
                        movePiece(-backSteps);
                    }, 1500);
                    return;

                case 'bouncing_bomb':
                    // Bom n·∫£y - n·ªï x l·∫ßn m·ªói 2 ho·∫∑c 3 √¥
                    const bombTimes = Math.floor(Math.random() * 3) + 2; // 2-4 l·∫ßn
                    const bombInterval = Math.random() < 0.5 ? 2 : 3; // 2 ho·∫∑c 3 √¥
                    message = `üí£üí• ${eventInfo.desc} - ${bombTimes} l·∫ßn m·ªói ${bombInterval} √¥!`;
                    showEvent(message);
                    playSound('event');
                    setTimeout(() => {
                        let killed = false;
                        const startPos = position;
                        
                        // N·ªï bom t·∫°i c√°c v·ªã tr√≠ c√°ch nhau bombInterval √¥
                        for (let i = 0; i < bombTimes; i++) {
                            const bombPos = normalizePosition(startPos + (i + 1) * bombInterval);
                            if (cells[bombPos] && cells[bombPos].dataset.type === 'player' && !cells[bombPos].classList.contains('dead')) {
                                const pIdx = parseInt(cells[bombPos].dataset.playerIndex);
                                const cellKey = cells[bombPos].dataset.cellKey;
                                if (!playerWinners.has(pIdx) && !deadPlayers.has(cellKey) && !deadPlayers.has(pIdx)) {
                                    if (killPlayer(pIdx, bombPos)) killed = true;
                                }
                            }
                        }
                        
                        if (!killed) {
                            showEvent('üí£üí• Bom n·∫£y kh√¥ng tr√∫ng ng∆∞·ªùi ch∆°i n√†o!');
                        }
                        
                        checkAndRevivePlayers();
                        isMoving = false;
                        diceBtn.disabled = false;
                    }, 1500);
                    return;

                case 'portal':
                    // Portal - ƒëi t·∫Øt sang √¥ kia
                    message = `üåÄ ${eventInfo.desc}`;
                    showEvent(message);
                    setTimeout(() => {
                        const otherPortal = portalPairs.find(p => p !== position);
                        if (otherPortal !== undefined) {
                            cells[currentPosition].classList.remove('current');
                            currentPosition = otherPortal;
                            if (gamePiece && gamePiece.parentNode) {
                                gamePiece.parentNode.removeChild(gamePiece);
                            }
                            cells[currentPosition].appendChild(gamePiece);
                            cells[currentPosition].classList.add('current');
                            cells[currentPosition].scrollIntoView({ behavior: 'smooth', block: 'center' });
                            showEvent(`üåÄ ƒê√£ d·ªãch chuy·ªÉn ƒë·∫øn √¥ ${otherPortal + 1}!`);
                            setTimeout(() => handleCellLanding(currentPosition), 1000);
                        }
                    }, 1500);
                    return;

                // === T·∫§N C√îNG ===
                case 'kill_random':
                    message = `‚öîÔ∏è ${eventInfo.desc}`;
                    showEvent(message);
                    playSound('event');
                    setTimeout(() => {
                        const aliveCells = [];
                        for (let i = 0; i < cells.length; i++) {
                            if (cells[i].dataset.type === 'player' && !cells[i].classList.contains('dead')) {
                                const pIdx = parseInt(cells[i].dataset.playerIndex);
                                const cellKey = cells[i].dataset.cellKey;
                                if (!deadPlayers.has(cellKey) && !deadPlayers.has(pIdx) && !playerWinners.has(pIdx)) {
                                    aliveCells.push({ cellIndex: i, playerIndex: pIdx });
                                }
                            }
                        }
                        if (aliveCells.length > 0) {
                            const random = aliveCells[Math.floor(Math.random() * aliveCells.length)];
                            killPlayer(random.playerIndex, random.cellIndex);
                        }
                        checkAndRevivePlayers();
                        isMoving = false;
                        diceBtn.disabled = false;
                    }, 1500);
                    return;

                case 'kill_forward':
                    message = `‚öîÔ∏è ${eventInfo.desc}`;
                    showEvent(message);
                    playSound('event');
                    setTimeout(() => {
                        const nearest = findNearestPlayer(position, 'forward');
                        if (nearest !== -1) {
                            const pIdx = parseInt(cells[nearest].dataset.playerIndex);
                            killPlayer(pIdx, nearest);
                        }
                        checkAndRevivePlayers();
                        isMoving = false;
                        diceBtn.disabled = false;
                    }, 1500);
                    return;

                case 'kill_backward':
                    message = `‚öîÔ∏è ${eventInfo.desc}`;
                    showEvent(message);
                    playSound('event');
                    setTimeout(() => {
                        const nearest = findNearestPlayer(position, 'backward');
                        if (nearest !== -1) {
                            const pIdx = parseInt(cells[nearest].dataset.playerIndex);
                            killPlayer(pIdx, nearest);
                        }
                        checkAndRevivePlayers();
                        isMoving = false;
                        diceBtn.disabled = false;
                    }, 1500);
                    return;

                case 'bomb_row':
                    message = `üí£ ${eventInfo.desc}`;
                    showEvent(message);
                    playSound('event');
                    setTimeout(() => {
                        const row = Math.floor(position / GRID_COLS);
                        let killed = false;
                        const rowStart = row * GRID_COLS;
                        const rowEnd = Math.min(rowStart + GRID_COLS, TOTAL_CELLS);
                        for (let i = rowStart; i < rowEnd; i++) {
                            if (cells[i] && cells[i].dataset.type === 'player' && !cells[i].classList.contains('dead')) {
                                const pIdx = parseInt(cells[i].dataset.playerIndex);
                                if (!playerWinners.has(pIdx) && killPlayer(pIdx, i)) killed = true;
                            }
                        }
                        if (!killed) showEvent('üí£ Kh√¥ng c√≥ ng∆∞·ªùi ch∆°i n√†o trong h√†ng!');
                        checkAndRevivePlayers();
                        isMoving = false;
                        diceBtn.disabled = false;
                    }, 1500);
                    return;

                case 'bomb_col':
                    message = `üí£ ${eventInfo.desc}`;
                    showEvent(message);
                    playSound('event');
                    setTimeout(() => {
                        const col = position % GRID_COLS;
                        let killed = false;
                        for (let i = col; i < TOTAL_CELLS; i += GRID_COLS) {
                            if (cells[i] && cells[i].dataset.type === 'player' && !cells[i].classList.contains('dead')) {
                                const pIdx = parseInt(cells[i].dataset.playerIndex);
                                if (!playerWinners.has(pIdx) && killPlayer(pIdx, i)) killed = true;
                            }
                        }
                        if (!killed) showEvent('üí£ Kh√¥ng c√≥ ng∆∞·ªùi ch∆°i n√†o trong c·ªôt!');
                        checkAndRevivePlayers();
                        isMoving = false;
                        diceBtn.disabled = false;
                    }, 1500);
                    return;

                case 'bomb_cross':
                    message = `üí• ${eventInfo.desc}`;
                    showEvent(message);
                    playSound('event');
                    setTimeout(() => {
                        const row = Math.floor(position / GRID_COLS);
                        const col = position % GRID_COLS;
                        let killed = false;
                        
                        // Bom h√†ng ngang
                        const rowStart = row * GRID_COLS;
                        const rowEnd = Math.min(rowStart + GRID_COLS, TOTAL_CELLS);
                        for (let i = rowStart; i < rowEnd; i++) {
                            if (cells[i] && cells[i].dataset.type === 'player' && !cells[i].classList.contains('dead')) {
                                const pIdx = parseInt(cells[i].dataset.playerIndex);
                                if (!playerWinners.has(pIdx) && killPlayer(pIdx, i)) killed = true;
                            }
                        }
                        
                        // Bom h√†ng d·ªçc
                        for (let i = col; i < TOTAL_CELLS; i += GRID_COLS) {
                            if (cells[i] && cells[i].dataset.type === 'player' && !cells[i].classList.contains('dead')) {
                                const pIdx = parseInt(cells[i].dataset.playerIndex);
                                if (!playerWinners.has(pIdx) && killPlayer(pIdx, i)) killed = true;
                            }
                        }
                        
                        if (!killed) showEvent('üí• Kh√¥ng c√≥ ng∆∞·ªùi ch∆°i n√†o b·ªã ·∫£nh h∆∞·ªüng!');
                        checkAndRevivePlayers();
                        isMoving = false;
                        diceBtn.disabled = false;
                    }, 1500);
                    return;

                // === PH√íNG TH·ª¶ ===
                case 'shield':
                    message = `üõ°Ô∏è ${eventInfo.desc}`;
                    showEvent(message);
                    playSound('event');
                    setTimeout(() => {
                        // ƒê·∫øm s·ªë √¥ t·∫•n c√¥ng tr√™n b·∫£n ƒë·ªì
                        let attackCellCount = 0;
                        for (let i = 0; i < cells.length; i++) {
                            if (cells[i].dataset.type === 'event') {
                                const eventType = cells[i].dataset.eventType;
                                if (eventType && (eventType.startsWith('kill_') || eventType.startsWith('bomb_') || eventType === 'bouncing_bomb')) {
                                    attackCellCount++;
                                }
                            }
                        }
                        
                        // T√≠nh s·ªë √¥ khi√™n c·∫ßn th√™m = 20% s·ªë √¥ t·∫•n c√¥ng (l√†m tr√≤n xu·ªëng)
                        const shieldCellsToAdd = Math.floor(attackCellCount * 0.2);
                        
                        // Ch·ªçn ng·∫´u nhi√™n 1-3 ng∆∞·ªùi ch∆°i ƒë·ªÉ t·∫°o khi√™n
                        const alivePlayers = [];
                        for (let i = 0; i < cells.length; i++) {
                            if (cells[i].dataset.type === 'player' && !cells[i].classList.contains('dead')) {
                                const pIdx = parseInt(cells[i].dataset.playerIndex);
                                const cellKey = cells[i].dataset.cellKey;
                                if (!playerWinners.has(pIdx) && !deadPlayers.has(cellKey) && !deadPlayers.has(pIdx)) {
                                    if (!alivePlayers.includes(pIdx)) {
                                        alivePlayers.push(pIdx);
                                    }
                                }
                            }
                        }
                        
                        // Ch·ªçn ng·∫´u nhi√™n 1-3 ng∆∞·ªùi ch∆°i
                        const shieldCount = Math.min(Math.floor(Math.random() * 3) + 1, alivePlayers.length);
                        const shuffled = [...alivePlayers].sort(() => Math.random() - 0.5);
                        const selectedPlayers = shuffled.slice(0, shieldCount);
                        
                        // T·∫°o khi√™n cho c√°c ng∆∞·ªùi ch∆°i ƒë∆∞·ª£c ch·ªçn
                        const shieldedNames = [];
                        selectedPlayers.forEach(playerIdx => {
                            playerShields[playerIdx] = true;
                            shieldedNames.push(originalPlayers[playerIdx]);
                        });
                        
                        let shieldMessage = '';
                        if (shieldedNames.length > 0) {
                            shieldMessage = `üõ°Ô∏è ${shieldedNames.join(', ')} ƒë√£ nh·∫≠n ƒë∆∞·ª£c khi√™n b·∫£o v·ªá!`;
                        }
                        
                        // Th√™m c√°c √¥ khi√™n m·ªõi v√†o b·∫£n ƒë·ªì
                        const shieldCellsAdded = [];
                        if (shieldCellsToAdd > 0) {
                            // T√¨m c√°c √¥ tr·ªëng (kh√¥ng ph·∫£i player, event, won, ho·∫∑c √¥ 0)
                            const emptyCells = [];
                            for (let i = 1; i < TOTAL_CELLS; i++) {
                                const cellType = cells[i].dataset.type;
                                const isEvent = eventCells.includes(i);
                                const isWon = cells[i].dataset.won === 'true';
                                if ((!cellType || cellType === 'empty') && !isEvent && !isWon) {
                                    emptyCells.push(i);
                                }
                            }
                            
                            // X√°o tr·ªôn v√† ch·ªçn c√°c √¥ ƒë·ªÉ th√™m khi√™n
                            const shuffledEmpty = [...emptyCells].sort(() => Math.random() - 0.5);
                            const cellsToAdd = Math.min(shieldCellsToAdd, shuffledEmpty.length);
                            
                            for (let i = 0; i < cellsToAdd; i++) {
                                const cellIdx = shuffledEmpty[i];
                                cells[cellIdx].className = 'cell event defense';
                                cells[cellIdx].textContent = 'üõ°Ô∏è';
                                cells[cellIdx].dataset.type = 'event';
                                cells[cellIdx].dataset.eventType = 'shield';
                                cells[cellIdx].dataset.tooltip = 'T·∫°o khi√™n cho 1-3 ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n + th√™m √¥ khi√™n';
                                cells[cellIdx].title = 'T·∫°o khi√™n cho 1-3 ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n + th√™m √¥ khi√™n';
                                cells[cellIdx].dataset.cellNumber = cellIdx + 1;
                                
                                eventData[cellIdx] = { type: 'shield', icon: 'üõ°Ô∏è', desc: 'T·∫°o khi√™n cho 1-3 ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n + th√™m √¥ khi√™n', category: 'defense' };
                                eventCells.push(cellIdx);
                                shieldCellsAdded.push(cellIdx + 1);
                            }
                            
                            if (shieldCellsAdded.length > 0) {
                                shieldMessage += ` ƒê√£ th√™m ${shieldCellsAdded.length} √¥ khi√™n v√†o c√°c √¥: ${shieldCellsAdded.join(', ')}.`;
                                addToHistory(`üõ°Ô∏è ƒê√£ th√™m ${shieldCellsAdded.length} √¥ khi√™n v√†o c√°c √¥: ${shieldCellsAdded.join(', ')}.`, false);
                            }
                        }
                        
                        if (shieldMessage) {
                            showEvent(shieldMessage);
                            if (shieldedNames.length > 0) {
                                addToHistory(`üõ°Ô∏è ${shieldedNames.join(', ')} ƒë√£ nh·∫≠n ƒë∆∞·ª£c khi√™n b·∫£o v·ªá!`, false);
                            }
                        }
                        
                        saveGameData();
                        isMoving = false;
                        diceBtn.disabled = false;
                    }, 1500);
                    return;
            }

            // M·∫∑c ƒë·ªãnh
            isMoving = false;
            diceBtn.disabled = false;
        }

        // Hi·ªÉn th·ªã th√¥ng b√°o ch√∫c m·ª´ng
        function showCongratulations(player, prize) {
            const congrats = document.getElementById('congratulations');
            document.getElementById('congratsPlayer').textContent = player;
            document.getElementById('congratsPrize').textContent = `Nh·∫≠n ƒë∆∞·ª£c: ${prize}`;
            congrats.classList.add('active');
            
            setTimeout(() => {
                congrats.classList.remove('active');
            }, 3000);
        }

        // Th√™m k·∫øt qu·∫£ v√†o zone999
        function addResult(player, prize, playerIndex = -1) {
            // Hi·ªÉn th·ªã th√¥ng b√°o ch√∫c m·ª´ng
            showCongratulations(player, prize);

            // Th√™m v√†o zone999 (b√™n tr√°i)
            const resultsContainer = document.getElementById('resultsContainer');
            const resultItem = document.createElement('div');
            resultItem.className = 'result-item';
            resultItem.innerHTML = `
                <span><strong>${player}</strong></span>
                <span>${prize}</span>
            `;
            resultsContainer.appendChild(resultItem);
            resultsContainer.scrollTop = resultsContainer.scrollHeight;

            // Th√™m v√†o l·ªãch s·ª≠ v·ªõi th√¥ng tin ng∆∞·ªùi chi·∫øn th·∫Øng
            addToHistory(`üèÜ ${player} tr√∫ng th∆∞·ªüng: ${prize}`, false);
            saveGameData(); // L∆∞u d·ªØ li·ªáu khi c√≥ k·∫øt qu·∫£ m·ªõi
        }

        // H√†m ti√™u di·ªát ng∆∞·ªùi ch∆°i (ch·ªâ ·ªü cell c·ª• th·ªÉ)
        function killPlayer(playerIndex, cellIndex = -1) {
            if (playerIndex < 0 || playerIndex >= originalPlayers.length || playerWinners.has(playerIndex)) {
                return false;
            }

            // T√¨m cell c·ª• th·ªÉ n·∫øu c√≥
            let targetCell = null;
            let cellKey = null;
            
            if (cellIndex >= 0 && cells[cellIndex] && cells[cellIndex].dataset.type === 'player' && 
                parseInt(cells[cellIndex].dataset.playerIndex) === playerIndex) {
                targetCell = cells[cellIndex];
                cellKey = targetCell.dataset.cellKey || `${cellIndex}_${playerIndex}`;
            } else {
                // T√¨m cell ƒë·∫ßu ti√™n c√≥ player n√†y
                for (let i = 0; i < cells.length; i++) {
                    if (cells[i].dataset.type === 'player' && parseInt(cells[i].dataset.playerIndex) === playerIndex) {
                        targetCell = cells[i];
                        cellKey = targetCell.dataset.cellKey || `${i}_${playerIndex}`;
                        cellIndex = i;
                        break;
                    }
                }
            }

            if (!targetCell) return false;

            // Ki·ªÉm tra xem cell n√†y ƒë√£ ch·∫øt ch∆∞a
            if (deadPlayers.has(cellKey) || deadPlayers.has(playerIndex)) {
                return false;
            }

            // Ki·ªÉm tra shield (ch·ªâ cho player index, kh√¥ng ph·∫£i cell c·ª• th·ªÉ)
            if (playerShields[playerIndex]) {
                playerShields[playerIndex] = false;
                showEvent(`üõ°Ô∏è ${originalPlayers[playerIndex]} ƒë√£ d√πng khi√™n ƒë·ªÉ ch·ªëng l·∫°i t·∫•n c√¥ng!`);
                return false;
            }

            // ƒê√°nh d·∫•u cell n√†y l√† dead (kh√¥ng ·∫£nh h∆∞·ªüng c√°c cell kh√°c)
            deadPlayers.add(cellKey);
            // Hi·ªÉn th·ªã s·ªë √¥ ƒë√∫ng (cellIndex + 1 v√¨ ƒë·∫øm t·ª´ 1)
            const cellNumber = cellIndex + 1;
            showEvent(`üíÄ ${originalPlayers[playerIndex]} ƒë√£ b·ªã ti√™u di·ªát ·ªü √¥ ${cellNumber}!`);
            playSound('kill');
            
            // C·∫≠p nh·∫≠t grid - ƒë√°nh d·∫•u √¥ l√† dead (gi·ªØ nguy√™n t√™n)
            targetCell.classList.add('dead');
            targetCell.style.background = '#3c3c3c';
            targetCell.style.color = '#ecf0f1';
            targetCell.style.border = '2px solid #2c2c2c';
            
            return true;
        }

        // H√†m l·∫•y v·ªã tr√≠ t·ª´ cell index
        function getCellPositionFromIndex(cellIndex) {
            const row = Math.floor(cellIndex / GRID_COLS);
            const col = cellIndex % GRID_COLS;
            return `${row}${col}`;
        }

        // H√†m l·∫•y v·ªã tr√≠ √¥ c·ªßa player (cell ƒë·∫ßu ti√™n t√¨m th·∫•y)
        function getCellPosition(playerIndex) {
            for (let i = 0; i < cells.length; i++) {
                if (cells[i].dataset.type === 'player' && parseInt(cells[i].dataset.playerIndex) === playerIndex) {
                    return getCellPositionFromIndex(i);
                }
            }
            return '?';
        }

        // H√†m t√¨m ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t
        function findNearestPlayer(position, direction = 'forward') {
            let nearestPlayer = -1;
            let minDistance = TOTAL_CELLS;
            
            for (let i = 0; i < cells.length; i++) {
                if (cells[i] && cells[i].dataset.type === 'player' && !cells[i].classList.contains('dead')) {
                    const pIdx = parseInt(cells[i].dataset.playerIndex);
                    const cellKey = cells[i].dataset.cellKey;
                    if (!deadPlayers.has(cellKey) && !deadPlayers.has(pIdx) && !playerWinners.has(pIdx)) {
                        let distance;
                        if (direction === 'forward') {
                            distance = i > position ? (i - position) : (i + TOTAL_CELLS - position);
                        } else {
                            distance = i < position ? (position - i) : (position + TOTAL_CELLS - i);
                        }
                        if (distance > 0 && distance < minDistance) {
                            minDistance = distance;
                            nearestPlayer = i;
                        }
                    }
                }
            }
            
            return nearestPlayer;
        }

        // L∆∞u d·ªØ li·ªáu v√†o localStorage
        function saveGameData() {
            if (isLoadingData) return; // Kh√¥ng l∆∞u khi ƒëang load
            try {
                // L∆∞u th√¥ng tin c√°c √¥ ƒë√£ tr√∫ng th∆∞·ªüng
                const wonCells = [];
                cells.forEach((cell, idx) => {
                    if (cell.dataset.won === 'true') {
                        wonCells.push({
                            index: idx,
                            playerIndex: parseInt(cell.dataset.playerIndex) || -1
                        });
                    }
                });
                
                const gameData = {
                    playersInput: document.getElementById('playersInput').value,
                    prizesInput: document.getElementById('prizesInput').value,
                    gameStarted: gameStarted,
                    currentPosition: currentPosition,
                    originalPlayers: originalPlayers,
                    originalPrizes: originalPrizes,
                    players: players,
                    prizes: prizes,
                    deadPlayers: Array.from(deadPlayers),
                    playerWinners: Array.from(playerWinners),
                    playerShields: playerShields,
                    turnCount: turnCount,
                    roundCount: roundCount,
                    playerRepeatMultiplier: playerRepeatMultiplier,
                    eventMultiplier: eventMultiplier,
                lastWinTurn: lastWinTurn,
                gameHistory: gameHistory,
                resultsHTML: document.getElementById('resultsContainer').innerHTML,
                historyHTML: document.getElementById('historyContainer').innerHTML,
                avatarImage: avatarImage,
                shouldMoveBackward: shouldMoveBackward,
                eventCells: eventCells,
                eventData: eventData,
                portalPairs: portalPairs,
                wonCells: wonCells
            };
                localStorage.setItem('giveAwayGameData', JSON.stringify(gameData));
            } catch (e) {
                console.error('L·ªói khi l∆∞u d·ªØ li·ªáu:', e);
            }
        }

        // Load d·ªØ li·ªáu t·ª´ localStorage
        function loadGameData() {
            isLoadingData = true; // ƒê√°nh d·∫•u ƒëang load
            const savedData = localStorage.getItem('giveAwayGameData');
            if (savedData) {
                try {
                    const gameData = JSON.parse(savedData);
                    
                    // Kh√¥i ph·ª•c input
                    if (gameData.playersInput) {
                        document.getElementById('playersInput').value = gameData.playersInput;
                    }
                    if (gameData.prizesInput) {
                        document.getElementById('prizesInput').value = gameData.prizesInput;
                    }
                    
                    // Kh√¥i ph·ª•c tr·∫°ng th√°i game n·∫øu ƒëang ch∆°i
                    if (gameData.gameStarted) {
                        originalPlayers = gameData.originalPlayers || [];
                        originalPrizes = gameData.originalPrizes || [];
                        players = gameData.players || [];
                        prizes = gameData.prizes || [];
                        deadPlayers = new Set(gameData.deadPlayers || []);
                        playerWinners = new Set(gameData.playerWinners || []);
                        playerShields = gameData.playerShields || {};
                        turnCount = gameData.turnCount || 0;
                        roundCount = gameData.roundCount || 0;
                        playerRepeatMultiplier = gameData.playerRepeatMultiplier || 1;
                        eventMultiplier = gameData.eventMultiplier || 1;
                        lastWinTurn = gameData.lastWinTurn || 0;
                        gameHistory = gameData.gameHistory || [];
                        currentPosition = gameData.currentPosition || 0;
                        avatarImage = gameData.avatarImage || null;
                        shouldMoveBackward = gameData.shouldMoveBackward || false;
                        eventCells = gameData.eventCells || [];
                        eventData = gameData.eventData || {};
                        portalPairs = gameData.portalPairs || [];
                        const wonCells = gameData.wonCells || [];
                        
                        // Kh√¥i ph·ª•c k·∫øt qu·∫£ v√† l·ªãch s·ª≠
                        if (gameData.resultsHTML) {
                            document.getElementById('resultsContainer').innerHTML = gameData.resultsHTML;
                        }
                        if (gameData.historyHTML) {
                            document.getElementById('historyContainer').innerHTML = gameData.historyHTML;
                        }
                        
                        // Kh√¥i ph·ª•c avatar n·∫øu c√≥
                        if (avatarImage) {
                            const preview = document.getElementById('avatarPreview');
                            if (preview) {
                                preview.src = avatarImage;
                                preview.style.display = 'block';
                            }
                        }
                        
                        // Kh·ªüi t·∫°o grid v√† kh√¥i ph·ª•c game
                        initGrid();
                        gameStarted = true;
                        
                        // Kh√¥i ph·ª•c event cells tr∆∞·ªõc khi ph√¢n b·ªï players
                        if (eventCells.length > 0) {
                            eventCells.forEach(idx => {
                                if (cells[idx] && eventData[idx]) {
                                    const eventInfo = eventData[idx];
                                    cells[idx].className = `cell event ${eventInfo.category}`;
                                    cells[idx].textContent = eventInfo.icon;
                                    cells[idx].dataset.type = 'event';
                                    cells[idx].dataset.eventType = eventInfo.type;
                                    cells[idx].dataset.tooltip = eventInfo.desc;
                                    cells[idx].title = eventInfo.desc;
                                    // ƒê·∫£m b·∫£o c√≥ data-cell-number ƒë·ªÉ hi·ªÉn th·ªã s·ªë th·ª© t·ª±
                                    cells[idx].dataset.cellNumber = idx + 1;
                                }
                            });
                        }
                        
                        // Kh√¥i ph·ª•c c√°c √¥ ƒë√£ tr√∫ng th∆∞·ªüng (n·∫øu c√≥)
                        wonCells.forEach(({ index, playerIndex }) => {
                            if (cells[index] && playerIndex >= 0 && originalPlayers[playerIndex]) {
                                cells[index].classList.add('player', 'winner');
                                cells[index].textContent = originalPlayers[playerIndex];
                                cells[index].dataset.type = 'player';
                                cells[index].dataset.playerIndex = playerIndex;
                                cells[index].dataset.won = 'true';
                                cells[index].dataset.cellKey = `${index}_${playerIndex}`;
                            }
                        });
                        
                        distributePlayers(false);
                        createGamePiece();
                        
                        // Kh√¥i ph·ª•c v·ªã tr√≠ qu√¢n c·ªù
                        if (cells[currentPosition] && gamePiece) {
                            cells[currentPosition].appendChild(gamePiece);
                            cells[currentPosition].classList.add('current');
                        }
                        
                        // Hi·ªÉn th·ªã n√∫t gieo x√∫c x·∫Øc
                        document.getElementById('diceBtn').style.display = 'block';
                        document.getElementById('startBtn').style.display = 'none';
                        
                        // C·∫≠p nh·∫≠t countdown
                        updateLuckyCountdown();
                    }
                    
                    checkStartButton();
                    updateLuckyCountdown();
                } catch (e) {
                    console.error('L·ªói khi load d·ªØ li·ªáu:', e);
                }
            }
            isLoadingData = false; // Ho√†n t·∫•t load
        }

        // X√≥a t·∫•t c·∫£ d·ªØ li·ªáu
        function clearAllData() {
            if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a t·∫•t c·∫£ d·ªØ li·ªáu v√† b·∫Øt ƒë·∫ßu l·∫°i?')) {
                localStorage.removeItem('giveAwayGameData');
                
                // Reset t·∫•t c·∫£
                document.getElementById('playersInput').value = '';
                document.getElementById('prizesInput').value = '';
                document.getElementById('resultsContainer').innerHTML = '';
                document.getElementById('historyContainer').innerHTML = '';
                document.getElementById('avatarPreview').style.display = 'none';
                document.getElementById('diceBtn').style.display = 'none';
                document.getElementById('startBtn').style.display = 'block';
                document.getElementById('startBtn').disabled = true;
                document.getElementById('startBtn').style.opacity = '0.5';
                document.getElementById('startBtn').style.cursor = 'not-allowed';
                
                originalPlayers = [];
                originalPrizes = [];
                players = [];
                prizes = [];
                deadPlayers = new Set();
                playerWinners = new Set();
                playerShields = {};
                gameHistory = [];
                turnCount = 0;
                roundCount = 0;
                playerRepeatMultiplier = 1;
                eventMultiplier = 1;
                lastWinTurn = 0;
                currentPosition = 0;
                gameStarted = false;
                avatarImage = null;
                shouldMoveBackward = false;
                
                initGrid();
                checkStartButton();
            }
        }


        // N√∫t X√ìA T·∫§T C·∫¢
        document.getElementById('clearBtn').addEventListener('click', clearAllData);

        // L∆∞u d·ªØ li·ªáu ƒë·ªãnh k·ª≥ v√† khi c√≥ s·ª± ki·ªán
        setInterval(saveGameData, 5000); // L∆∞u m·ªói 5 gi√¢y

        // C·∫≠p nh·∫≠t countdown l∆∞·ª£t may m·∫Øn
        function updateLuckyCountdown() {
            const countdownEl = document.getElementById('luckyCountdown');
            if (!countdownEl) return;
            
            if (turnCount === 0) {
                countdownEl.textContent = 'üí° Sau m·ªói 7 l∆∞·ª£t gieo x√≠ ng·∫ßu, 25% ng∆∞·ªùi ch∆°i may m·∫Øn s·∫Ω ƒë∆∞·ª£c th√™m v√†o c√°c √¥ tr·ªëng! (C√≤n 7 l∆∞·ª£t)';
                return;
            }
            
            const remaining = 7 - (turnCount % 7);
            if (remaining === 7) {
                countdownEl.textContent = 'üí° Sau m·ªói 7 l∆∞·ª£t gieo x√≠ ng·∫ßu, 25% ng∆∞·ªùi ch∆°i may m·∫Øn s·∫Ω ƒë∆∞·ª£c th√™m v√†o c√°c √¥ tr·ªëng! (ƒê·∫øn l∆∞·ª£t!)';
            } else {
                countdownEl.textContent = `üí° Sau m·ªói 7 l∆∞·ª£t gieo x√≠ ng·∫ßu, 25% ng∆∞·ªùi ch∆°i may m·∫Øn s·∫Ω ƒë∆∞·ª£c th√™m v√†o c√°c √¥ tr·ªëng! (C√≤n ${remaining} l∆∞·ª£t)`;
            }
        }

        // Kh·ªüi t·∫°o
        initGrid();
        checkStartButton(); // Ki·ªÉm tra tr·∫°ng th√°i n√∫t khi trang load
        loadGameData(); // Load d·ªØ li·ªáu khi trang load
        updateLuckyCountdown(); // C·∫≠p nh·∫≠t countdown khi trang load
    </script>
</body>
</html>
