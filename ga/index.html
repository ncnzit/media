<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Give Away - NguyeZ Gaming</title>
    
    <!-- Meta Description -->
    <meta name="description" content="Tr√≤ ch∆°i Give Away c·ªßa NguyeZ Gaming - Gieo x√≠ ng·∫ßu D21 v√† trao ph·∫ßn th∆∞·ªüng cho ng∆∞·ªùi ch∆°i may m·∫Øn. Game gi·∫£i tr√≠ v·ªõi nhi·ªÅu s·ª± ki·ªán th√∫ v·ªã v√† ph·∫ßn th∆∞·ªüng h·∫•p d·∫´n.">
    <meta name="keywords" content="give away, nguyez gaming, tr√≤ ch∆°i, x√≠ ng·∫ßu, ph·∫ßn th∆∞·ªüng, game online">
    <meta name="author" content="NguyeZ Gaming">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://nguyez.com/giveaway/">
    <meta property="og:title" content="Give Away - NguyeZ Gaming">
    <meta property="og:description" content="Tr√≤ ch∆°i Give Away c·ªßa NguyeZ Gaming - Gieo x√≠ ng·∫ßu D21 v√† trao ph·∫ßn th∆∞·ªüng cho ng∆∞·ªùi ch∆°i may m·∫Øn. Game gi·∫£i tr√≠ v·ªõi nhi·ªÅu s·ª± ki·ªán th√∫ v·ªã v√† ph·∫ßn th∆∞·ªüng h·∫•p d·∫´n.">
    <meta property="og:image" content="https://media.nguyez.com/IMG/AVT-NguyeZGaming.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="NguyeZ Gaming">
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://nguyez.com/giveaway/">
    <meta name="twitter:title" content="Give Away - NguyeZ Gaming">
    <meta name="twitter:description" content="Tr√≤ ch∆°i Give Away c·ªßa NguyeZ Gaming - Gieo x√≠ ng·∫ßu D21 v√† trao ph·∫ßn th∆∞·ªüng cho ng∆∞·ªùi ch∆°i may m·∫Øn. Game gi·∫£i tr√≠ v·ªõi nhi·ªÅu s·ª± ki·ªán th√∫ v·ªã v√† ph·∫ßn th∆∞·ªüng h·∫•p d·∫´n.">
    <meta name="twitter:image" content="https://media.nguyez.com/IMG/AVT-NguyeZGaming.png">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="https://media.nguyez.com/IMG/AVT-NguyeZGaming.png">
    <link rel="shortcut icon" type="image/png" href="https://media.nguyez.com/IMG/AVT-NguyeZGaming.png">
    <link rel="apple-touch-icon" href="https://media.nguyez.com/IMG/AVT-NguyeZGaming.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
            color: #fff;
        }

        .container {
            display: flex;
            height: 100vh;
            padding: 20px;
            gap: 20px;
        }

        .left-panel {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            max-height: calc(100vh - 80px);
            padding-right: 10px;
        }

        .left-panel::-webkit-scrollbar {
            width: 6px;
        }

        .left-panel::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
        }

        .title {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 10px;
        }

        .input-sections-container {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 12px;
            display: flex;
            gap: 12px;
            max-height: 180px;
            overflow: hidden;
        }

        .input-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .input-section.scrollable {
            max-height: 200px;
            overflow-y: auto;
        }

        .input-section h3 {
            margin-bottom: 10px;
            font-size: 17px;
            text-align: center;
            font-weight: normal;
        }

        .input-section textarea {
            min-height: 80px;
            max-height: 130px;
            padding: 8px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            background: rgba(255,255,255,0.9);
            color: #333;
            font-size: 13px;
            resize: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow-y: auto;
            line-height: 1.6;
            width: 100%;
            box-sizing: border-box;
        }

        .input-section textarea:focus {
            outline: none;
            border-color: #fff;
        }

        .start-btn {
            padding: 8px 16px;
            font-size: 14px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
            backdrop-filter: blur(5px);
        }

        .start-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #f5a5fb 0%, #f6677c 100%);
            border-color: rgba(255,255,255,0.5);
            transform: scale(1.05);
        }

        .start-btn:active:not(:disabled) {
            transform: scale(0.95);
        }

        .start-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 0;
            overflow: hidden;
        }

        .zone3 {
            flex: 1;
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 10px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-width: 0;
            max-width: 100%;
            box-sizing: border-box;
        }

        .grid-wrapper {
            flex: 1;
            overflow: auto;
            position: relative;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            min-width: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .grid-container {
            display: grid;
            gap: 4px;
            width: 100%;
            height: 100%;
            min-height: 0;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        .grid-container > .cell {
            aspect-ratio: 1;
            min-width: 0;
            min-height: 0;
        }

        .grid-label {
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            color: #fff;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }

        .grid-label.row {
            grid-column: 1;
        }

        .grid-label.col {
            grid-row: 1;
        }

        .cell {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            position: relative;
            transition: all 0.3s;
            cursor: pointer;
            padding: 5px;
            text-align: center;
            word-wrap: break-word;
            overflow: hidden;
            min-width: 0;
            width: 100%;
            height: 100%;
        }

        .cell::after {
            content: attr(data-cell-number);
            position: absolute;
            bottom: 3px;
            right: 5px;
            font-size: 14px;
            color: rgba(255,255,255,0.7);
            font-weight: bold;
            line-height: 1;
            z-index: 5;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        /* √î s·ª± ki·ªán: d√πng ::before cho s·ªë th·ª© t·ª±, ::after cho tooltip */
        .cell.event::before {
            content: attr(data-cell-number);
            position: absolute;
            bottom: 3px;
            right: 5px;
            font-size: 14px;
            color: rgba(255,255,255,0.7);
            font-weight: bold;
            line-height: 1;
            z-index: 5;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .cell:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.05);
        }

        .cell.player {
            background: #ddd;
            font-weight: 500;
            color: #14b84c;
            font-size: 17px;
            white-space: normal;
            word-wrap: break-word;
            line-height: 1.2;
        }

        /* ƒê·∫£m b·∫£o s·ªë th·ª© t·ª± lu√¥n hi·ªÉn th·ªã cho t·∫•t c·∫£ cells */
        .cell.player::after {
            content: attr(data-cell-number);
            position: absolute;
            bottom: 3px;
            right: 5px;
            font-size: 14px;
            color: rgba(0,0,0,0.5);
            font-weight: bold;
            line-height: 1;
            z-index: 5;
        }

        .cell.player.dead {
            background: #3c3c3c;
            color: #ecf0f1;
            border: 2px solid #2c2c2c;
        }

        .cell.player.dead::before {
            content: "üíÄ ";
            font-size: 24px;
            margin-right: 2px;
        }

        /* ƒê·∫£m b·∫£o s·ªë th·ª© t·ª± hi·ªÉn th·ªã cho dead cells */
        .cell.player.dead::after {
            content: attr(data-cell-number);
            position: absolute;
            bottom: 3px;
            right: 5px;
            font-size: 14px;
            color: rgba(255,255,255,0.7);
            font-weight: bold;
            line-height: 1;
            z-index: 5;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .cell.player.winner {
            background: #f39c12;
            color: #2c3e50;
            border: 2px solid #d68910;
        }

        .cell.player.winner::before {
            content: "üèÜ ";
            font-size: 20px;
            margin-right: 2px;
        }

        /* ƒê·∫£m b·∫£o s·ªë th·ª© t·ª± hi·ªÉn th·ªã cho winner cells */
        .cell.player.winner::after {
            content: attr(data-cell-number);
            position: absolute;
            bottom: 3px;
            right: 5px;
            font-size: 14px;
            color: rgba(0,0,0,0.6);
            font-weight: bold;
            line-height: 1;
            z-index: 5;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
        }
        
        /* ƒê·∫£m b·∫£o t√™n v·∫´n hi·ªÉn th·ªã khi c√≥ icon c√∫p */
        .cell.player.winner {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Event cells - Di chuy·ªÉn (Movement) - M√†u flat */
        .cell.event.movement {
            background: #3498db;
            font-weight: bold;
            font-size: 32px;
            position: relative;
            border: 2px solid #2980b9;
        }

        /* Event cells - T·∫•n c√¥ng (Attack) - M√†u flat */
        .cell.event.attack {
            background: #e74c3c;
            font-weight: bold;
            font-size: 32px;
            position: relative;
            border: 2px solid #c0392b;
        }


        .cell.event {
            position: relative;
        }

        .cell.event::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(100% + 5px);
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            background: rgba(0,0,0,0.9);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            white-space: normal;
            word-wrap: break-word;
            word-break: break-word;
            max-width: 280px;
            min-width: 120px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.05s ease-out, transform 0.05s ease-out;
            transition-delay: 0s;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            width: auto;
            box-sizing: border-box;
            display: block;
            line-height: 1.5;
            text-align: left;
        }

        .cell.event:hover::after {
            opacity: 1;
            transform: translateX(-50%) translateY(-5px);
        }

        /* Tooltip cho c√°c lo·∫°i event */
        .cell[data-event-type="move_forward"]::after {
            content: "‚¨ÜÔ∏è Di chuy·ªÉn: Ti·∫øn th√™m 1-5 √¥";
        }

        .cell[data-event-type="move_backward"]::after {
            content: "‚¨áÔ∏è Di chuy·ªÉn: L√πi x √¥ (l√πi ·ªü l·∫ßn gieo x√≠ ng·∫ßu ti·∫øp theo)";
        }

        .cell[data-event-type="jump_row"]::after {
            content: "‚¨áÔ∏è Di chuy·ªÉn: Nh·∫£y xu·ªëng h√†ng d·ªçc: Nh·∫£y xu·ªëng h√†ng d∆∞·ªõi";
        }

        .cell[data-event-type="kill_on_path"]::after {
            content: "üíÄ T·∫•n c√¥ng: Gi·∫´m ƒë·∫°p - Nh·ªØng √¥ ƒëi qua trong l∆∞·ª£t ƒë·ªï x√≠ ng·∫ßu ti·∫øp theo s·∫Ω ti√™u di·ªát nh·ªØng ng∆∞·ªùi ch∆°i b·ªã gi·∫´m qua";
        }


        .cell[data-event-type="hop"]::after {
            content: "ü¶ò Di chuy·ªÉn: ƒêi nh·∫£y c√≥c (m·ªói l·∫ßn 2 √¥)";
        }

        .cell[data-event-type="portal"]::after {
            content: "üåÄ Di chuy·ªÉn: Portal - ƒêi t·∫Øt sang portal ng·∫´u nhi√™n (5 portal tr√™n b·∫£n ƒë·ªì)";
        }

        .cell[data-event-type="kill_random"]::after {
            content: "‚öîÔ∏è T·∫•n c√¥ng: Ti√™u di·ªát 1 ƒë·∫øn 5 ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n";
        }

        .cell[data-event-type="kill_nearest"]::after {
            content: "‚öîÔ∏è T·∫•n c√¥ng: Ti√™u di·ªát 1 ƒë·∫øn 5 ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t";
        }

        .cell[data-event-type="bomb_row"]::after {
            content: "üí£ T·∫•n c√¥ng: Bom h√†ng ngang - Ng∆∞·ªùi ch∆°i c√πng h√†ng b·ªã ti√™u di·ªát h·∫øt";
        }

        .cell[data-event-type="bomb_col"]::after {
            content: "üí£ T·∫•n c√¥ng: Bom h√†ng d·ªçc - Ng∆∞·ªùi ch∆°i c√πng c·ªôt b·ªã ti√™u di·ªát h·∫øt";
        }

        .cell[data-event-type="bomb_cross"]::after {
            content: "üí• T·∫•n c√¥ng: Bom ch·ªØ th·∫≠p - Ng∆∞·ªùi ch∆°i c√πng h√†ng v√† c·ªôt b·ªã ti√™u di·ªát h·∫øt";
        }

        .cell[data-event-type="cleanse"]::after {
            content: "‚ú® T·∫•n c√¥ng: Thanh t·∫©y - L√†m tr·ªëng ng·∫´u nhi√™n x √¥ (x: 3-10)";
        }

        .cell.current {
            box-shadow: 0 0 20px #00ff00;
            border-color: #00ff00;
            z-index: 10;
        }

        .cell.visited {
            background: rgba(0, 0, 0, 0.3);
        }

        /* Animation cho c√°c √¥ b·ªã ·∫£nh h∆∞·ªüng b·ªüi s·ª± ki·ªán */
        .cell.affected {
            animation: affectedPulse 0.5s ease-in-out infinite;
            box-shadow: 0 0 20px #ff0000, 0 0 30px #ff0000, 0 0 40px #ff0000;
            z-index: 50;
        }

        @keyframes affectedPulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 20px #ff0000, 0 0 30px #ff0000, 0 0 40px #ff0000;
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 0 30px #ff0000, 0 0 40px #ff0000, 0 0 50px #ff0000;
            }
        }

        .game-piece {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: top 0.3s ease-out, left 0.3s ease-out, opacity 0.3s ease;
            z-index: 100;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            overflow: hidden;
            pointer-events: none;
        }
        
        /* ƒê·∫£m b·∫£o tooltip c√≥ th·ªÉ hi·ªÉn th·ªã khi c√≥ game-piece */
        .cell:hover .game-piece {
            pointer-events: none;
        }

        .cell.player .game-piece,
        .cell.event .game-piece {
            opacity: 0.3;
        }

        .game-piece img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
            display: block;
        }

        .zone999 {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 12px;
            max-height: 180px;
            overflow-y: auto;
        }

        .zone999 h3 {
            margin-bottom: 8px;
            text-align: center;
            font-size: 17px;
            font-weight: normal;
        }

        .copy-btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: #fff;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .copy-btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.5);
            transform: scale(1.05);
        }

        .copy-btn:active {
            transform: scale(0.95);
        }

        .result-item {
            background: rgba(255,255,255,0.2);
            padding: 6px 10px;
            margin-bottom: 4px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }

        .stages-section {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
            max-height: 150px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .stages-section::-webkit-scrollbar {
            width: 6px;
        }

        .stages-section::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
        }

        .stages-section h3 {
            margin-bottom: 8px;
            text-align: center;
            font-size: 17px;
            flex-shrink: 0;
            font-weight: normal;
        }

        #stagesContainer {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex: 1;
            overflow-y: auto;
        }

        .stage-item {
            background: rgba(255,255,255,0.2);
            padding: 8px 10px;
            border-radius: 5px;
            border-left: 3px solid rgba(255,255,255,0.3);
            transition: all 0.3s ease;
        }

        .stage-item.inactive {
            opacity: 0.4;
            background: rgba(255,255,255,0.1);
        }

        .stage-item.active {
            opacity: 1;
            background: rgba(255,255,255,0.3);
            border-left-color: #ffd700;
            box-shadow: 0 0 10px rgba(255,215,0,0.3);
        }

        .stage-title {
            font-weight: bold;
            font-size: 13px;
            margin-bottom: 4px;
            color: #fff;
        }

        .stage-desc {
            font-size: 11px;
            color: rgba(255,255,255,0.9);
        }

        .rules-btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: #fff;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .rules-btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.5);
            transform: scale(1.05);
        }

        .rules-btn:active {
            transform: scale(0.95);
        }

        .rules-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 3000;
            justify-content: center;
            align-items: center;
        }

        .rules-modal.active {
            display: flex;
        }

        .rules-modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            position: relative;
        }

        .mobile-warning-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 4000;
            justify-content: center;
            align-items: center;
        }

        .mobile-warning-modal.active {
            display: flex;
        }

        .mobile-warning-content {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            position: relative;
            text-align: center;
            animation: popIn 0.5s ease-out;
        }

        .mobile-warning-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: rgba(255,255,255,0.2);
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .mobile-warning-content h2 {
            font-size: 24px;
            margin-bottom: 15px;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .mobile-warning-content p {
            font-size: 16px;
            color: #fff;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .mobile-warning-btn {
            background: rgba(255,255,255,0.3);
            border: 2px solid rgba(255,255,255,0.5);
            color: #fff;
            padding: 12px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
        }

        .mobile-warning-btn:hover {
            background: rgba(255,255,255,0.4);
            transform: scale(1.05);
        }

        .mobile-warning-btn:active {
            transform: scale(0.95);
        }

        .mobile-warning-close:hover {
            background: rgba(255,255,255,0.3);
        }

        .rules-modal-close:hover {
            background: rgba(255,255,255,0.3);
            transform: rotate(90deg);
        }

        .rules-modal h2 {
            color: #fff;
            margin-bottom: 20px;
            text-align: center;
            font-size: 24px;
        }

        .rules-section {
            margin-bottom: 20px;
        }

        .rules-section h3 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .rules-section p {
            color: rgba(255,255,255,0.9);
            line-height: 1.6;
            margin-bottom: 8px;
        }

        .event-info-section {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .event-info-section h3 {
            margin-bottom: 8px;
            text-align: center;
            font-size: 17px;
            font-weight: normal;
        }

        .event-info-item {
            padding: 6px 8px;
            margin: 4px 0;
            border-radius: 4px;
            font-size: 12px;
            background: rgba(255,255,255,0.1);
        }

        .event-info-item.movement {
            border-left: 3px solid #4facfe;
        }

        .event-info-item.attack {
            border-left: 3px solid #f5576c;
        }

        .event-info-item.defense {
            border-left: 3px solid #43e97b;
        }

        .history-section {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 12px;
            max-height: 200px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .history-section::-webkit-scrollbar {
            width: 6px;
        }

        .history-section::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
        }

        .history-section h3 {
            margin-bottom: 8px;
            text-align: center;
            font-size: 17px;
            flex-shrink: 0;
            font-weight: normal;
        }

        .history-item {
            background: rgba(255,255,255,0.1);
            padding: 6px 8px;
            margin: 4px 0;
            border-radius: 4px;
            font-size: 12px;
            border-left: 3px solid rgba(255,255,255,0.3);
            flex-shrink: 0;
        }

        #historyContainer {
            flex: 1;
            overflow-y: auto;
        }

        #historyContainer::-webkit-scrollbar {
            width: 6px;
        }

        #historyContainer::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
        }

        .congratulations {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            padding: 40px 60px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 2000;
            display: none;
            text-align: center;
            animation: popIn 0.5s ease-out;
        }

        .congratulations.active {
            display: block;
        }

        @keyframes popIn {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .congratulations h2 {
            font-size: 36px;
            margin-bottom: 15px;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .congratulations p {
            font-size: 24px;
            color: #fff;
            margin: 10px 0;
        }

        .dice-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 20px;
            display: none;
            z-index: 1000;
            text-align: center;
        }

        .dice-container.active {
            display: block;
        }

        .dice {
            font-size: 100px;
            animation: roll 0.5s infinite;
        }

        @keyframes roll {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(90deg); }
            50% { transform: rotate(180deg); }
            75% { transform: rotate(270deg); }
        }

        .dice-result {
            font-size: 24px;
            margin-top: 20px;
            color: #fff;
        }

        .file-upload {
            margin-bottom: 10px;
        }

        .file-upload input {
            display: none;
        }

        .file-upload label {
            display: block;
            padding: 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: background 0.3s;
        }

        .file-upload label:hover {
            background: rgba(255,255,255,0.3);
        }

        .uploaded-image {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin: 10px auto;
            display: block;
        }

        .dice-btn {
            padding: 15px 30px;
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: block;
            margin: 10px auto;
            width: fit-content;
        }

        .dice-btn-container {
            padding: 10px;
            text-align: center;
        }

        .dice-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .dice-btn:active {
            transform: translateY(0);
        }

        .dice-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: scale(0.95);
        }

        .event-display {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            margin-top: 10px;
            min-height: 80px;
            display: none;
        }

        .event-display.active {
            display: block;
        }

        .event-display h4 {
            margin-bottom: 10px;
            font-size: 18px;
            color: #fee140;
            font-weight: normal;
        }

        .event-display p {
            font-size: 16px;
            line-height: 1.5;
        }

        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            text-align: center;
            font-size: 14px;
            color: #fff;
            z-index: 100;
            border-top: 1px solid rgba(255,255,255,0.2);
        }

        .footer a {
            color: #4facfe;
            text-decoration: none;
            transition: color 0.3s;
        }

        .footer a:hover {
            color: #00f2fe;
            text-decoration: underline;
        }

        body {
            padding-bottom: 50px;
        }

        /* ============================================
           RESPONSIVE DESIGN - M√ÄN H√åNH CHI·ªÄU CAO > 1080px
           ============================================ */
        @media screen and (min-height: 1081px) {
            .stages-section {
                min-height: 190px;
            }

            .zone999 {
                min-height: 190px;
            }

            .history-section {
                min-height: 220px;
            }

            .input-sections-container {
                min-height: 180px;
                max-height: 180px;
            }

            .input-section textarea {
                min-height: 120px;
                max-height: 120px;
            }
        }

        /* ============================================
           RESPONSIVE DESIGN - M√ÄN H√åNH CHI·ªÄU CAO < 1080px
           ============================================ */
        @media screen and (max-height: 1080px) {
            .input-sections-container {
                min-height: 120px;
                max-height: 200px;
            }

            .input-section textarea {
                min-height: 60px;
                max-height: 150px;
            }

            .stages-section {
                min-height: 120px;
                max-height: 180px;
            }

            .zone999 {
                min-height: 120px;
                max-height: 200px;
            }

            .history-section {
                min-height: 120px;
                max-height: 220px;
            }

            .event-info-section {
                min-height: 120px;
                max-height: 220px;
            }
        }

        /* ============================================
           RESPONSIVE DESIGN - TABLET (768px - 1024px)
           ============================================ */
        @media screen and (max-width: 1024px) and (min-width: 769px) {
            .container {
                padding: 15px;
                gap: 15px;
            }

            .left-panel {
                width: 280px;
                gap: 12px;
                overflow-y: auto;
                overflow-x: hidden;
                max-height: calc(100vh - 30px);
                padding-right: 10px;
            }
            
            .left-panel::-webkit-scrollbar {
                width: 8px;
            }
            
            .left-panel::-webkit-scrollbar-track {
                background: rgba(255,255,255,0.1);
                border-radius: 4px;
            }
            
            .left-panel::-webkit-scrollbar-thumb {
                background: rgba(255,255,255,0.4);
                border-radius: 4px;
            }
            
            .left-panel::-webkit-scrollbar-thumb:hover {
                background: rgba(255,255,255,0.6);
            }

            .title {
                font-size: 26px;
                padding: 12px;
            }

            .input-section h3 {
                font-size: 16px;
            }

            .input-section textarea {
                font-size: 12px;
                min-height: 70px;
                max-height: 120px;
            }

            .start-btn {
                padding: 12px 24px;
                font-size: 18px;
            }

            .game-piece {
                width: 60px;
                height: 60px;
                font-size: 16px;
            }

            .cell {
                font-size: 16px;
            }

            .cell.player {
                font-size: 15px;
            }

            .cell.event {
                font-size: 24px;
            }

            .cell::after,
            .cell.event::before {
                font-size: 12px;
            }

            .zone999 h3,
            .stages-section h3,
            .history-section h3 {
                font-size: 14px;
            }

            .stage-title {
                font-size: 12px;
            }

            .stage-desc {
                font-size: 10px;
            }

            .history-item,
            .result-item {
                font-size: 11px;
                padding: 5px 8px;
            }

            .rules-modal-content {
                max-width: 90%;
                padding: 25px;
            }

            .rules-modal h2 {
                font-size: 20px;
            }

            .rules-section h3 {
                font-size: 16px;
            }

            .rules-section p {
                font-size: 14px;
            }

            .dice {
                font-size: 80px;
            }

            .dice-result {
                font-size: 20px;
            }

            .congratulations {
                padding: 30px 50px;
            }

            .congratulations h2 {
                font-size: 28px;
            }

            .congratulations p {
                font-size: 20px;
            }
        }

        /* ============================================
           RESPONSIVE DESIGN - MOBILE (< 768px)
           ============================================ */
        @media screen and (max-width: 768px) {
            body {
                overflow-y: auto;
                overflow-x: hidden;
                height: auto;
                min-height: 100vh;
            }

            .container {
                flex-direction: column;
                padding: 10px;
                gap: 10px;
                height: auto;
                min-height: 100vh;
            }

            .left-panel {
                width: 100%;
                max-height: none;
                overflow-y: visible;
                order: 1;
                padding-right: 0;
            }

            .right-panel {
                order: 2;
                width: 100%;
                min-height: 50vh;
            }

            .title {
                font-size: 22px;
                padding: 10px;
                margin-bottom: 8px;
            }

            .input-sections-container {
                flex-direction: column;
                padding: 10px;
                max-height: none;
            }

            .input-section {
                padding: 0;
            }

            .input-section.scrollable {
                max-height: 150px;
            }

            .input-section h3 {
                font-size: 14px;
                margin-bottom: 8px;
            }

            .input-section textarea {
                font-size: 13px;
                min-height: 60px;
                max-height: 100px;
                padding: 6px;
            }

            .start-btn {
                padding: 12px 20px;
                font-size: 16px;
                min-height: 44px; /* Touch-friendly */
            }

            .rules-btn {
                padding: 10px 14px;
                font-size: 13px;
                min-height: 44px; /* Touch-friendly */
            }

            .zone3 {
                padding: 8px;
                min-height: 400px;
            }

            .grid-wrapper {
                min-height: 350px;
            }

            .game-piece {
                width: 35px;
                height: 35px;
                font-size: 12px;
            }

            .cell {
                font-size: 10px;
                padding: 2px;
                border-width: 1px;
            }

            .cell.player {
                font-size: 9px;
                line-height: 1.1;
            }

            .cell.player.dead::before {
                font-size: 16px;
            }

            .cell.player.winner::before {
                font-size: 14px;
            }

            .cell.event {
                font-size: 14px;
            }

            .cell.event.movement,
            .cell.event.attack {
                font-size: 14px;
            }

            .cell::after,
            .cell.event::before,
            .cell.player::after,
            .cell.player.dead::after,
            .cell.player.winner::after {
                font-size: 8px;
                bottom: 1px;
                right: 2px;
            }

            .cell.event::after {
                font-size: 9px;
                padding: 4px 8px;
                max-width: 180px;
                min-width: 80px;
                white-space: normal;
                word-wrap: break-word;
                word-break: break-word;
                line-height: 1.4;
                transition: opacity 0.05s ease-out, transform 0.05s ease-out;
                transition-delay: 0s;
            }

            .grid-label {
                font-size: 10px;
            }

            .stages-section {
                padding: 10px;
                max-height: 120px;
            }

            .stages-section h3 {
                font-size: 13px;
            }

            .stage-item {
                padding: 6px 8px;
            }

            .stage-title {
                font-size: 11px;
                margin-bottom: 3px;
            }

            .stage-desc {
                font-size: 9px;
            }

            .zone999 {
                padding: 10px;
                max-height: 150px;
            }

            .zone999 h3 {
                font-size: 13px;
            }

            .result-item {
                font-size: 10px;
                padding: 4px 6px;
            }

            .copy-btn {
                padding: 6px 10px;
                font-size: 11px;
                min-height: 32px; /* Touch-friendly */
            }

            .history-section {
                padding: 10px;
                max-height: 150px;
            }

            .history-section h3 {
                font-size: 13px;
            }

            .history-item {
                font-size: 10px;
                padding: 4px 6px;
            }

            .event-display {
                padding: 10px;
                min-height: 60px;
            }

            .event-display h4 {
                font-size: 14px;
            }

            .event-display p {
                font-size: 12px;
            }

            .dice-btn {
                padding: 12px 24px;
                font-size: 16px;
                min-height: 44px; /* Touch-friendly */
                width: 100%;
                max-width: 300px;
            }

            .dice-container {
                padding: 20px;
            }

            .dice {
                font-size: 60px;
            }

            .dice-result {
                font-size: 18px;
                margin-top: 15px;
            }

            .congratulations {
                padding: 20px 30px;
                max-width: 90%;
                margin: 0 auto;
            }

            .congratulations h2 {
                font-size: 24px;
                margin-bottom: 10px;
            }

            .congratulations p {
                font-size: 16px;
                margin: 8px 0;
            }

            .rules-modal-content {
                max-width: 95%;
                max-height: 90vh;
                padding: 20px;
                margin: 10px;
            }

            .rules-modal-close {
                width: 35px;
                height: 35px;
                font-size: 28px;
                top: 8px;
                right: 10px;
            }

            .rules-modal h2 {
                font-size: 18px;
                margin-bottom: 15px;
            }

            .rules-section {
                margin-bottom: 15px;
            }

            .rules-section h3 {
                font-size: 14px;
                margin-bottom: 8px;
            }

            .rules-section h4 {
                font-size: 13px;
                margin-top: 12px;
                margin-bottom: 6px;
            }

            .rules-section p {
                font-size: 12px;
                line-height: 1.5;
                margin-bottom: 6px;
            }

            .footer {
                padding: 8px 10px;
                font-size: 12px;
                position: relative;
            }

            body {
                padding-bottom: 60px;
            }

            /* Touch-friendly spacing */
            div[style*="display: flex"] {
                gap: 8px;
            }

            /* Upload image preview */
            .uploaded-image {
                width: 40px;
                height: 40px;
            }

            /* Hide hover effects on mobile */
            .cell:hover {
                transform: none;
            }

            .start-btn:hover:not(:disabled),
            .rules-btn:hover,
            .copy-btn:hover,
            .dice-btn:hover {
                transform: none;
            }
        }

        /* ============================================
           RESPONSIVE DESIGN - SMALL MOBILE (< 480px)
           ============================================ */
        @media screen and (max-width: 480px) {
            .container {
                padding: 8px;
                gap: 8px;
            }

            .title {
                font-size: 18px;
                padding: 8px;
            }

            .input-section {
                padding: 8px;
            }

            .input-section h3 {
                font-size: 13px;
            }

            .input-section textarea {
                font-size: 12px;
                min-height: 50px;
                max-height: 80px;
            }

            .start-btn,
            .dice-btn {
                font-size: 14px;
                padding: 10px 16px;
            }

            .rules-btn {
                font-size: 12px;
                padding: 8px 12px;
            }

            .cell {
                font-size: 10px;
            }

            .cell.player {
                font-size: 10px;
            }

            .cell.event {
                font-size: 16px;
            }

            .cell::after,
            .cell.event::before {
                font-size: 8px;
            }

            .game-piece {
                width: 40px;
                height: 40px;
                font-size: 12px;
            }

            .zone3 {
                min-height: 300px;
            }

            .grid-wrapper {
                min-height: 280px;
            }

            .rules-modal-content {
                padding: 15px;
            }

            .rules-modal h2 {
                font-size: 16px;
            }

            .rules-section h3 {
                font-size: 13px;
            }

            .rules-section p {
                font-size: 11px;
            }

            .congratulations h2 {
                font-size: 20px;
            }

            .congratulations p {
                font-size: 14px;
            }

            .dice {
                font-size: 50px;
            }
        }

        /* ============================================
           LANDSCAPE ORIENTATION - MOBILE
           ============================================ */
        @media screen and (max-width: 768px) and (orientation: landscape) {
            .container {
                flex-direction: row;
            }

            .left-panel {
                width: 35%;
                max-height: calc(100vh - 20px);
                overflow-y: auto;
            }

            .right-panel {
                width: 65%;
                min-height: calc(100vh - 20px);
            }

            .zone3 {
                min-height: calc(100vh - 100px);
            }

            .grid-wrapper {
                min-height: calc(100vh - 150px);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="left-panel">
            <div class="title">Give Away</div>
            
            <div class="input-sections-container">
                <div class="input-section">
                    <h3>üìã Ng∆∞·ªùi ch∆°i</h3>
                    <textarea id="playersInput" placeholder="M·ªói d√≤ng l√† 1 ng∆∞·ªùi ch∆°i&#10;V√≠ d·ª•:&#10;1. Ng∆∞·ªùi ch∆°i 1&#10;2. Ng∆∞·ªùi ch∆°i 2"></textarea>
                </div>

                <div class="input-section">
                    <h3>Ph·∫ßn th∆∞·ªüng üéÅ</h3>
                    <textarea id="prizesInput" placeholder="M·ªói d√≤ng l√† 1 ph·∫ßn th∆∞·ªüng&#10;V√≠ d·ª•:&#10;1. Ph·∫ßn th∆∞·ªüng 1&#10;2. Ph·∫ßn th∆∞·ªüng 2"></textarea>
                </div>
            </div>

            <div class="stages-section">
                <h3>üìä C√°c Giai ƒêo·∫°n</h3>
                <div id="stagesContainer">
                    <div class="stage-item inactive" id="stage1">
                        <div class="stage-title" id="stage1Title">Giai ƒëo·∫°n 1</div>
                        <div class="stage-desc">Hi·ªÉn th·ªã 33% ng∆∞·ªùi ch∆°i</div>
                    </div>
                    <div class="stage-item inactive" id="stage2">
                        <div class="stage-title" id="stage2Title">Giai ƒëo·∫°n 2</div>
                        <div class="stage-desc">Th√™m 33% ng∆∞·ªùi ch∆°i (t·ªïng 66%)</div>
                    </div>
                    <div class="stage-item inactive" id="stage3">
                        <div class="stage-title" id="stage3Title">Giai ƒëo·∫°n 3</div>
                        <div class="stage-desc">Th√™m ph·∫ßn c√≤n l·∫°i (t·ªïng 100%)</div>
                    </div>
                    <div class="stage-item inactive" id="stageLucky">
                        <div class="stage-title" id="stageLuckyTitle">Ng∆∞·ªùi ch∆°i may m·∫Øn</div>
                        <div class="stage-desc">Sau m·ªói 7 l∆∞·ª£t, 25% ng∆∞·ªùi ch∆°i may m·∫Øn ƒë∆∞·ª£c th√™m v√†o c√°c √¥ tr·ªëng</div>
                    </div>
                    <div class="stage-item inactive" id="stageFull">
                        <div class="stage-title" id="stageFullTitle">Thanh t·∫©y khi ƒë·∫ßy</div>
                        <div class="stage-desc">Khi t·∫•t c·∫£ √¥ ƒë√£ c√≥ t√™n ng∆∞·ªùi ch∆°i, thanh t·∫©y ng·∫´u nhi√™n 10 √¥</div>
                    </div>
                </div>
            </div>

            <div class="buttons-container" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 10px 0;">
                <button id="rulesBtn" class="rules-btn">üìñ Lu·∫≠t ch∆°i</button>
                <label for="avatarUpload" class="rules-btn" style="text-align: center; cursor: pointer; display: flex; align-items: center; justify-content: center;">
                    Upload ·∫£nh üñºÔ∏è
                    <input type="file" id="avatarUpload" accept="image/*" style="display: none;">
                </label>
                <button class="start-btn" id="startBtn">‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu</button>
                <button class="start-btn" id="clearBtn" style="background: #f5576c;">Xo√° üóëÔ∏è</button>
            </div>

            <div class="event-info-section" style="display: none;">
                <h3>üìã C√°c S·ª± Ki·ªán</h3>
                <div id="luckyCountdown" style="font-size: 11px; color: #ffd700; margin-bottom: 8px; padding: 5px; background: rgba(255,215,0,0.1); border-radius: 4px;">
                    üí° Sau m·ªói 7 l∆∞·ª£t gieo x√≠ ng·∫ßu, 25% ng∆∞·ªùi ch∆°i may m·∫Øn s·∫Ω ƒë∆∞·ª£c th√™m v√†o c√°c √¥ tr·ªëng!
                </div>
                <div class="event-info-item movement">‚¨ÜÔ∏è Di chuy·ªÉn: Ti·∫øn th√™m 1-5 √¥</div>
                <div class="event-info-item movement">‚¨áÔ∏è Di chuy·ªÉn: L√πi x √¥ (l√πi ·ªü l·∫ßn gieo x√≠ ng·∫ßu ti·∫øp theo)</div>
                <div class="event-info-item movement">‚¨áÔ∏è Di chuy·ªÉn: Nh·∫£y xu·ªëng h√†ng d·ªçc: Nh·∫£y xu·ªëng h√†ng d∆∞·ªõi</div>
                <div class="event-info-item attack">üíÄ T·∫•n c√¥ng: Gi·∫´m ƒë·∫°p - Nh·ªØng √¥ ƒëi qua trong l∆∞·ª£t ƒë·ªï x√≠ ng·∫ßu ti·∫øp theo s·∫Ω ti√™u di·ªát nh·ªØng ng∆∞·ªùi ch∆°i b·ªã gi·∫´m qua</div>
                <div class="event-info-item movement">üåÄ Di chuy·ªÉn: Portal - ƒêi t·∫Øt sang portal ng·∫´u nhi√™n (5 portal tr√™n b·∫£n ƒë·ªì)</div>
                <div class="event-info-item attack">‚öîÔ∏è T·∫•n c√¥ng: Ti√™u di·ªát 1 ƒë·∫øn 5 ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n</div>
                <div class="event-info-item attack">‚öîÔ∏è T·∫•n c√¥ng: Ti√™u di·ªát 1 ƒë·∫øn 5 ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t</div>
                <div class="event-info-item attack">üí£ T·∫•n c√¥ng: Bom h√†ng ngang</div>
                <div class="event-info-item attack">üí£ T·∫•n c√¥ng: Bom h√†ng d·ªçc</div>
                <div class="event-info-item attack">üí• T·∫•n c√¥ng: Bom ch·ªØ th·∫≠p (ngang + d·ªçc)</div>
                <div class="event-info-item attack">üí£üí• T·∫•n c√¥ng: Bom n·∫£y - n·ªï x l·∫ßn m·ªói 2-3 √¥</div>
                <div class="event-info-item attack">‚ú® T·∫•n c√¥ng: Thanh t·∫©y - L√†m tr·ªëng ng·∫´u nhi√™n x √¥ (x: 3-10)</div>
            </div>
            
            <div class="event-display" id="eventDisplay">
                <h4>‚ö° S·ª± Ki·ªán</h4>
                <p id="eventText"></p>
            </div>

            <div class="zone999">
                <div class="zone999-header" style="display: flex; justify-content: center; align-items: center; margin-bottom: 8px; position: relative;">
                    <h3 style="margin: 0; text-align: center; flex: 1;">üèÜ K·∫øt qu·∫£ trao th∆∞·ªüng</h3>
                    <button id="copyResultsBtn" class="copy-btn" title="Copy k·∫øt qu·∫£" style="display: none; position: absolute; right: 0;">
                        üìã Copy
                    </button>
                </div>
                <div id="resultsContainer"></div>
            </div>

            <div class="history-section">
                <h3>üìú L·ªãch S·ª≠ S·ª± Ki·ªán</h3>
                <div id="historyContainer"></div>
            </div>
        </div>

        <div class="right-panel">
            <div class="zone3" id="zone3">
                <div class="grid-wrapper">
                    <div class="grid-container" id="gridContainer"></div>
                </div>
                <div class="dice-btn-container">
                    <button class="dice-btn" id="diceBtn" disabled>üé≤ Nh√¢n Ph·∫©m üé≤</button>
                </div>
            </div>
        </div>
    </div>

    <div class="dice-container" id="diceContainer">
        <div class="dice">üé≤</div>
        <div class="dice-result" id="diceResult"></div>
    </div>

    <div class="congratulations" id="congratulations">
        <h2>üéâ Ch√∫c M·ª´ng! üéâ</h2>
        <p id="congratsPlayer"></p>
        <p id="congratsPrize"></p>
        <div id="congratsRemaining" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.3);"></div>
        <div id="congratsPrizesList" style="margin-top: 10px; max-height: 200px; overflow-y: auto; text-align: left; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px;"></div>
    </div>

    <!-- Modal Lu·∫≠t ch∆°i -->
    <div class="rules-modal" id="rulesModal">
        <div class="rules-modal-content">
            <button class="rules-modal-close" id="rulesModalClose">&times;</button>
            <h2>üìñ Lu·∫≠t Ch∆°i</h2>
            
            <div class="rules-section">
                <h3>üéÆ C√°ch Ch∆°i</h3>
                <p>B·∫°n c·∫ßn ƒëi·ªÅn danh s√°ch ng∆∞·ªùi ch∆°i v√† danh s√°ch ph·∫ßn th∆∞·ªüng sau ƒë√≥ b·∫•m <strong>B·∫Øt ƒë·∫ßu</strong> ƒë·ªÉ t·∫°o m√†n ch∆°i.</p>
                <p>C√≥ th·ªÉ <strong>Upload ·∫£nh</strong> qu√¢n c·ªù n·∫øu c·∫ßn thi·∫øt ƒë·ªÉ t√πy ch·ªânh h√¨nh ·∫£nh qu√¢n c·ªù tr√™n b√†n ch∆°i.</p>
                <p>Qu√¢n c·ªù s·∫Ω xu·∫•t hi·ªán ·ªü <strong>√¥ s·ªë 1</strong> (g√≥c tr√™n b√™n tr√°i) v√† di chuy·ªÉn t·ª´ tr√°i sang ph·∫£i theo s·ªë l∆∞·ª£t ƒë·ªï <strong>x√≠ ng·∫ßu D21</strong> (X√≠ ng·∫ßu 21 m·∫∑t).</p>
                <p>B·∫•m n√∫t <strong>üé≤ Nh√¢n Ph·∫©m üé≤</strong> ƒë·ªÉ gieo x√≠ ng·∫ßu D21 v√† di chuy·ªÉn qu√¢n c·ªù.</p>
                <p>Khi qu√¢n c·ªù di chuy·ªÉn v√†o √¥ c√≥ ng∆∞·ªùi ch∆°i th√¨ s·∫Ω trao ph·∫ßn th∆∞·ªüng cho ng∆∞·ªùi ch∆°i ƒë√≥. Tr√≤ ch∆°i k·∫øt th√∫c khi ƒë√£ trao h·∫øt t·∫•t c·∫£ ph·∫ßn th∆∞·ªüng.</p>
            </div>

            <div class="rules-section">
                <h3>üéØ C√°c Giai ƒêo·∫°n</h3>
                <p style="font-style: italic; color: rgba(255,255,255,0.8); margin-bottom: 10px; font-size: 13px;">C√°c Giai ƒêo·∫°n ƒë∆∞·ª£c chia ra ƒë·ªÉ tr√°nh tr∆∞·ªùng h·ª£p k·∫øt th√∫c qu√° nhanh ho·∫∑c k√©o d√†i qu√° l√¢u.</p>
                <p><strong>Giai ƒëo·∫°n 1:</strong> Ban ƒë·∫ßu ch·ªâ hi·ªÉn th·ªã 33% ng∆∞·ªùi ch∆°i (l√†m tr√≤n xu·ªëng)</p>
                <p><strong>Giai ƒëo·∫°n 2:</strong> Sau 5 l∆∞·ª£t gieo x√≠ ng·∫ßu, th√™m 33% ng∆∞·ªùi ch∆°i n·ªØa (t·ªïng 66%)</p>
                <p><strong>Giai ƒëo·∫°n 3:</strong> Sau 10 l∆∞·ª£t gieo x√≠ ng·∫ßu, th√™m ph·∫ßn c√≤n l·∫°i (t·ªïng 100%)</p>
                <p><strong>Ng∆∞·ªùi ch∆°i may m·∫Øn:</strong> T·ª´ sau l∆∞·ª£t 10, sau m·ªói 7 l∆∞·ª£t gieo x√≠ ng·∫ßu, 25% ng∆∞·ªùi ch∆°i may m·∫Øn s·∫Ω ƒë∆∞·ª£c th√™m v√†o c√°c √¥ tr·ªëng!</p>
            </div>

            <div class="rules-section">
                <h3>üìã C√°c S·ª± Ki·ªán</h3>
                
                <h4 style="color: #4fc3f7; margin-top: 15px; margin-bottom: 8px;">‚¨ÜÔ∏è Di chuy·ªÉn:</h4>
                <p>‚Ä¢ <strong>Ti·∫øn th√™m 1-5 √¥:</strong> Qu√¢n c·ªù ti·∫øn th√™m s·ªë √¥ ng·∫´u nhi√™n (sang ph·∫£i)</p>
                <p>‚Ä¢ <strong>L√πi x √¥:</strong> L√πi x √¥ ·ªü l·∫ßn gieo x√≠ ng·∫ßu ti·∫øp theo (x l√† s·ªë x√∫c x·∫Øc, sang tr√°i)</p>
                <p>‚Ä¢ <strong>Nh·∫£y xu·ªëng h√†ng d·ªçc:</strong> Nh·∫£y xu·ªëng h√†ng d∆∞·ªõi</p>
                <p>‚Ä¢ <strong>Nh·∫£y l√™n h√†ng d·ªçc:</strong> Nh·∫£y l√™n h√†ng tr√™n</p>
                <p>‚Ä¢ <strong>Portal:</strong> ƒêi t·∫Øt sang portal ng·∫´u nhi√™n (5 portal tr√™n b·∫£n ƒë·ªì)</p>
                
                <h4 style="color: #ef5350; margin-top: 15px; margin-bottom: 8px;">‚öîÔ∏è T·∫•n c√¥ng:</h4>
                <p>‚Ä¢ <strong>Ti√™u di·ªát 1 ƒë·∫øn 5 ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n</strong></p>
                <p>‚Ä¢ <strong>Ti√™u di·ªát 1 ƒë·∫øn 5 ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t</strong></p>
                <p>‚Ä¢ <strong>Bom h√†ng ngang:</strong> T·∫•t c·∫£ ng∆∞·ªùi ch∆°i c√πng h√†ng b·ªã ti√™u di·ªát</p>
                <p>‚Ä¢ <strong>Bom h√†ng d·ªçc:</strong> T·∫•t c·∫£ ng∆∞·ªùi ch∆°i c√πng c·ªôt b·ªã ti√™u di·ªát</p>
                <p>‚Ä¢ <strong>Bom ch·ªØ th·∫≠p:</strong> T·∫•t c·∫£ ng∆∞·ªùi ch∆°i c√πng h√†ng v√† c·ªôt b·ªã ti√™u di·ªát</p>
                <p>‚Ä¢ <strong>Bom n·∫£y:</strong> N·ªï x l·∫ßn m·ªói 2-3 √¥, ti√™u di·ªát ng∆∞·ªùi ch∆°i t·∫°i c√°c v·ªã tr√≠ ƒë√≥</p>
                <p>‚Ä¢ <strong>Gi·∫´m ƒë·∫°p:</strong> Nh·ªØng √¥ ƒëi qua trong l∆∞·ª£t ƒë·ªï x√≠ ng·∫ßu ti·∫øp theo s·∫Ω ti√™u di·ªát nh·ªØng ng∆∞·ªùi ch∆°i b·ªã gi·∫´m qua</p>
                <p>‚Ä¢ <strong>Thanh t·∫©y:</strong> L√†m tr·ªëng ng·∫´u nhi√™n x √¥ (x t·ª´ 3 ƒë·∫øn 10), c√°c √¥ k·ªÉ c·∫£ ng∆∞·ªùi ch∆°i l·∫´n s·ª± ki·ªán s·∫Ω th√†nh √¥ tr·ªëng</p>
            </div>

            <div class="rules-section" style="margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.3);">
                <p style="text-align: center; font-style: italic; color: rgba(255,255,255,0.8);">
                    Thi·∫øt k·∫ø b·∫±ng AI b·ªüi <a href="https://youtube.com/ncn1992vn" target="_blank" rel="noopener noreferrer" style="color: #ffd700; text-decoration: underline;">Ncn - NguyeZ Gaming</a>
                </p>
                <p style="text-align: center; font-style: italic; color: rgba(255,255,255,0.7); margin-top: 10px; font-size: 12px;">
                    * N·∫øu c√≥ BUG! Th√¨ ƒë·∫•y l√† m·ªôt t√≠nh nƒÉng ·∫©n mang t√≠nh b·∫•t ng·ªù.
                </p>
            </div>
        </div>
    </div>

    <footer class="footer">
        Thi·∫øt k·∫ø b·∫±ng AI b·ªüi <a href="https://youtube.com/ncn1992vn" target="_blank" rel="noopener noreferrer">Ncn - NguyeZ Gaming</a>
    </footer>

    <!-- Popup th√¥ng b√°o cho thi·∫øt b·ªã di ƒë·ªông -->
    <div class="mobile-warning-modal" id="mobileWarningModal">
        <div class="mobile-warning-content">
            <button class="mobile-warning-close" id="mobileWarningClose">&times;</button>
            <h2>‚ö†Ô∏è Th√¥ng b√°o</h2>
            <p>Giao di·ªán ch∆∞a t·ªëi ∆∞u cho c√°c thi·∫øt b·ªã di ƒë·ªông, ch·ªâ ho·∫°t ƒë·ªông t·ªët tr√™n phi√™n b·∫£n m√°y t√≠nh.</p>
            <button class="mobile-warning-btn" id="mobileWarningBtn">ƒê√£ hi·ªÉu</button>
        </div>
    </div>

    <script>
        let players = [];
        let prizes = [];
        let cells = [];
        let currentPosition = 0;
        let gamePiece = null;
        let avatarImage = null;
        let eventCells = [];
        let gameStarted = false;
        let isMoving = false;
        let eventData = {}; // L∆∞u th√¥ng tin event cho m·ªói cell
        let deadPlayers = new Set(); // L∆∞u danh s√°ch player ƒë√£ ch·∫øt
        let portalList = []; // L∆∞u danh s√°ch 5 portal
        let hasTeleported = false; // Flag ƒë·ªÉ tr√°nh portal teleport l·∫∑p l·∫°i
        let shouldKillOnPath = false; // Flag ƒë·ªÉ gi·∫øt ng∆∞·ªùi ch∆°i khi ƒëi qua trong l∆∞·ª£t ti·∫øp theo
        let playerWinners = new Set(); // L∆∞u danh s√°ch player ƒë√£ tr√∫ng th∆∞·ªüng
        let originalPlayers = []; // L∆∞u danh s√°ch player g·ªëc
        let originalPrizes = []; // L∆∞u danh s√°ch prize g·ªëc
        let gameHistory = []; // L∆∞u l·ªãch s·ª≠ s·ª± ki·ªán
        let turnCount = 0; // ƒê·∫øm s·ªë l∆∞·ª£t ch∆°i
        let roundCount = 0; // ƒê·∫øm s·ªë v√≤ng (m·ªói 2 l∆∞·ª£t = 1 v√≤ng)
        let playerRepeatMultiplier = 1; // H·ªá s·ªë l·∫∑p l·∫°i ng∆∞·ªùi ch∆°i
        let eventMultiplier = 1; // H·ªá s·ªë tƒÉng event cells
        let lastWinTurn = 0; // L∆∞·ª£t cu·ªëi c√πng c√≥ ng∆∞·ªùi tr√∫ng th∆∞·ªüng
        let playerCellMap = new Map(); // Map t·ª´ cell index -> player index (cho ph√©p nhi·ªÅu cell c√πng player)
        let hasPerformedFullCleanse = false; // ƒê√£ th·ª±c hi·ªán thanh t·∫©y khi ƒë·∫ßy ch∆∞a
        const GRID_COLS = 15; // S·ªë c·ªôt c·ªßa grid
        const GRID_ROWS = 7; // S·ªë h√†ng c·ªßa grid
        const TOTAL_CELLS = GRID_COLS * GRID_ROWS; // T·ªïng s·ªë √¥ (105)
        let isLoadingData = false; // Flag ƒë·ªÉ tr√°nh l∆∞u khi ƒëang load
        let shouldMoveBackward = false; // Flag ƒë·ªÉ l√πi ·ªü l·∫ßn gieo x√≠ ng·∫ßu ti·∫øp theo

        // Kh·ªüi t·∫°o grid v·ªõi k√≠ch th∆∞·ªõc responsive
        function initGrid() {
            const gridContainer = document.getElementById('gridContainer');
            gridContainer.innerHTML = '';
            cells = [];

            // Thi·∫øt l·∫≠p grid template d·ª±a tr√™n GRID_COLS v√† GRID_ROWS
            // C·ªôt: 1 c·ªôt nh√£n h√†ng (30px) + GRID_COLS c·ªôt cells (1fr m·ªói c·ªôt)
            // B·ªè h√†ng s·ªë 8 (nh√£n h√†ng cu·ªëi), n√™n ch·ªâ c√≤n GRID_ROWS h√†ng cells + 1 h√†ng nh√£n ƒë·∫ßu
            gridContainer.style.gridTemplateColumns = `30px repeat(${GRID_COLS}, 1fr)`;
            gridContainer.style.gridTemplateRows = `30px repeat(${GRID_ROWS}, 1fr)`;

            // T·∫°o √¥ g√≥c tr√™n tr√°i (s·ªë 0)
            const cornerCell = document.createElement('div');
            cornerCell.className = 'grid-label';
            cornerCell.textContent = '0';
            cornerCell.style.gridColumn = '1';
            cornerCell.style.gridRow = '1';
            gridContainer.appendChild(cornerCell);

            // T·∫°o nh√£n c·ªôt (1 ƒë·∫øn GRID_COLS) - g√≥c ƒë√£ l√† 0 r·ªìi
            for (let col = 1; col <= GRID_COLS; col++) {
                const label = document.createElement('div');
                label.className = 'grid-label col';
                label.textContent = col;
                label.style.gridColumn = col + 1;
                label.style.gridRow = '1';
                gridContainer.appendChild(label);
            }

            // T·∫°o c√°c h√†ng ch·ª©a cells v√† nh√£n h√†ng
            for (let row = 0; row < GRID_ROWS; row++) {
                // T·∫°o nh√£n h√†ng cho t·∫•t c·∫£ c√°c h√†ng
                // V√¨ ƒë√£ c√≥ s·ªë 0 ·ªü g√≥c (corner cell), n√™n nh√£n h√†ng b·∫Øt ƒë·∫ßu t·ª´ 1
                // Row 0 (cells) ‚Üí nh√£n 1, Row 1 (cells) ‚Üí nh√£n 2, ...
                const rowLabel = document.createElement('div');
                rowLabel.className = 'grid-label row';
                rowLabel.textContent = row + 1; // B·∫Øt ƒë·∫ßu t·ª´ 1 thay v√¨ 0
                rowLabel.style.gridColumn = '1';
                rowLabel.style.gridRow = row + 2;
                gridContainer.appendChild(rowLabel);

                // T·∫°o c√°c √¥ trong m·ªói h√†ng
                for (let col = 0; col < GRID_COLS; col++) {
                    const cellIndex = row * GRID_COLS + col;
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${cellIndex}`;
                    cell.dataset.index = cellIndex;
                    // ƒê·∫£m b·∫£o cellNumber lu√¥n ƒë∆∞·ª£c set (b·∫Øt ƒë·∫ßu t·ª´ 1)
                    const cellNumber = cellIndex + 1;
                    cell.dataset.cellNumber = cellNumber;
                    cell.style.gridColumn = col + 2;
                    cell.style.gridRow = row + 2;
                    gridContainer.appendChild(cell);
                    cells.push(cell);
                }
            }
            
            // Kh√¥ng t·∫°o nh√£n h√†ng cu·ªëi c√πng (h√†ng s·ªë 8) - ƒë√£ b·ªã x√≥a
        }

        // T·∫°o √¢m thanh ƒë∆°n gi·∫£n
        function playSound(type) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                switch(type) {
                    case 'dice':
                        oscillator.frequency.value = 400;
                        oscillator.type = 'sine';
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    case 'win':
                        oscillator.frequency.value = 523.25; // C5
                        oscillator.type = 'sine';
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.5);
                        break;
                    case 'event':
                        oscillator.frequency.value = 300;
                        oscillator.type = 'square';
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                    case 'kill':
                        oscillator.frequency.value = 150;
                        oscillator.type = 'sawtooth';
                        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    case 'move':
                        // √Çm thanh t√°ch t√°ch khi di chuy·ªÉn (gi·ªëng g√µ ph√≠m c∆°)
                        oscillator.frequency.value = 800;
                        oscillator.type = 'square';
                        gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.05);
                        break;
                }
            } catch(e) {
                // N·∫øu kh√¥ng th·ªÉ t·∫°o audio context, b·ªè qua
            }
        }

        // Ph√¢n b·ªï ng∆∞·ªùi ch∆°i v√† event cells
        function distributePlayers(isInitial = false) {
            // L∆∞u l·∫°i event cells c≈© n·∫øu kh√¥ng ph·∫£i l·∫ßn ƒë·∫ßu
            const oldEventIndices = [...eventCells];
            const oldEventData = { ...eventData };
            
            // Reset t·∫•t c·∫£ cells (tr·ª´ event cells v√† c√°c √¥ ƒë√£ tr√∫ng th∆∞·ªüng n·∫øu kh√¥ng ph·∫£i l·∫ßn ƒë·∫ßu)
            cells.forEach((cell, idx) => {
                // Gi·ªØ nguy√™n c√°c √¥ ƒë√£ tr√∫ng th∆∞·ªüng
                if (cell.dataset.won === 'true') {
                    return; // Kh√¥ng reset √¥ ƒë√£ tr√∫ng th∆∞·ªüng
                }
                
                if (isInitial || !oldEventIndices.includes(idx)) {
                    cell.className = 'cell';
                    cell.textContent = '';
                    cell.dataset.type = '';
                    cell.dataset.eventType = '';
                    cell.dataset.tooltip = '';
                    cell.title = '';
                    cell.dataset.won = '';
                    // ƒê·∫£m b·∫£o data-cell-number lu√¥n ƒë∆∞·ª£c set (s·ªë th·ª© t·ª± √¥, b·∫Øt ƒë·∫ßu t·ª´ 1)
                    cell.dataset.cellNumber = idx + 1;
                } else {
                    // ƒê·∫£m b·∫£o event cells gi·ªØ nguy√™n tooltip v√† cellNumber
                    if (oldEventData[idx]) {
                        cell.dataset.tooltip = oldEventData[idx].desc;
                        cell.title = oldEventData[idx].desc;
                    }
                    // ƒê·∫£m b·∫£o cellNumber lu√¥n ƒë∆∞·ª£c set
                    if (!cell.dataset.cellNumber) {
                        cell.dataset.cellNumber = idx + 1;
                    }
                }
            });

            // Ch·ªâ t·∫°o event cells m·ªõi n·∫øu l√† l·∫ßn ƒë·∫ßu
            if (isInitial) {
                eventCells = [];
                eventData = {};

                // T·∫°o event cells (tƒÉng t·∫ßn su·∫•t d·ª±a tr√™n t·ªïng s·ªë √¥)
                const baseEvents = Math.floor(Math.random() * (TOTAL_CELLS * 0.3)) + Math.floor(TOTAL_CELLS * 0.25);
                const numEvents = Math.min(Math.floor(baseEvents * eventMultiplier), Math.floor(TOTAL_CELLS * 0.5));
                const eventIndices = [];
                while (eventIndices.length < numEvents) {
                    const idx = Math.floor(Math.random() * TOTAL_CELLS);
                    if (!eventIndices.includes(idx) && idx !== 0) {
                        eventIndices.push(idx);
                    }
                }

                // ƒê·ªãnh nghƒ©a c√°c lo·∫°i event v·ªõi icon, m√¥ t·∫£ v√† category
                const movementEvents = [
                    { type: 'move_forward', icon: '‚û°Ô∏è', desc: 'Ti·∫øn th√™m 1-5 √¥', category: 'movement' },
                    { type: 'move_backward', icon: '‚¨ÖÔ∏è', desc: 'L√πi x √¥ (l√πi ·ªü l·∫ßn gieo x√≠ ng·∫ßu ti·∫øp theo)', category: 'movement' },
                    { type: 'jump_row', icon: '‚¨áÔ∏è', desc: 'Nh·∫£y xu·ªëng h√†ng d·ªçc: Nh·∫£y xu·ªëng h√†ng d∆∞·ªõi', category: 'movement' },
                    { type: 'jump_row_up', icon: '‚¨ÜÔ∏è', desc: 'Nh·∫£y l√™n h√†ng d·ªçc: Nh·∫£y l√™n h√†ng tr√™n', category: 'movement' },
                ];
                
                // T·∫•n c√¥ng - tƒÉng g·∫•p ƒë√¥i t·∫ßn su·∫•t b·∫±ng c√°ch duplicate
                const attackEvents = [
                    { type: 'kill_random', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát 1 ƒë·∫øn 5 ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n', category: 'attack' },
                    { type: 'kill_nearest', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát 1 ƒë·∫øn 5 ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t', category: 'attack' },
                    { type: 'bomb_row', icon: 'üí£', desc: 'Bom h√†ng ngang', category: 'attack' },
                    { type: 'bomb_col', icon: 'üí£', desc: 'Bom h√†ng d·ªçc', category: 'attack' },
                    { type: 'bomb_cross', icon: 'üí•', desc: 'Bom ch·ªØ th·∫≠p (ngang + d·ªçc)', category: 'attack' },
                    { type: 'bouncing_bomb', icon: 'üí£üí•', desc: 'Bom n·∫£y - n·ªï x l·∫ßn m·ªói 2-3 √¥', category: 'attack' },
                    // Duplicate ƒë·ªÉ tƒÉng g·∫•p ƒë√¥i t·∫ßn su·∫•t
                    { type: 'kill_random', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát 1 ƒë·∫øn 5 ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n', category: 'attack' },
                    { type: 'kill_nearest', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát 1 ƒë·∫øn 5 ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t', category: 'attack' },
                    { type: 'bomb_row', icon: 'üí£', desc: 'Bom h√†ng ngang', category: 'attack' },
                    { type: 'bomb_col', icon: 'üí£', desc: 'Bom h√†ng d·ªçc', category: 'attack' },
                    { type: 'bomb_cross', icon: 'üí•', desc: 'Bom ch·ªØ th·∫≠p (ngang + d·ªçc)', category: 'attack' },
                    { type: 'bouncing_bomb', icon: 'üí£üí•', desc: 'Bom n·∫£y - n·ªï x l·∫ßn m·ªói 2-3 √¥', category: 'attack' }
                ];
                
                // Th√™m s·ª± ki·ªán Thanh t·∫©y v√†o nh√≥m t·∫•n c√¥ng
                attackEvents.push(
                    { type: 'cleanse', icon: '‚ú®', desc: 'Thanh t·∫©y - L√†m tr·ªëng ng·∫´u nhi√™n x √¥ (x: 3-10)', category: 'attack' }
                );
                
                // G·ªôp t·∫•t c·∫£ event types
                const eventTypes = [...movementEvents, ...attackEvents];

                // T·∫°o 5 portal ng·∫´u nhi√™n (tr∆∞·ªõc khi t·∫°o event cells kh√°c)
                portalList = [];
                const portalIndices = [];
                while (portalIndices.length < 5) {
                    const idx = Math.floor(Math.random() * TOTAL_CELLS);
                    if (!eventIndices.includes(idx) && idx !== 0 && !portalIndices.includes(idx)) {
                        portalIndices.push(idx);
                        eventIndices.push(idx); // Th√™m v√†o eventIndices ƒë·ªÉ kh√¥ng b·ªã tr√πng
                    }
                }
                portalList = portalIndices;

                // T·∫°o 3-5 √¥ thanh t·∫©y ng·∫´u nhi√™n
                const cleanseCount = Math.floor(Math.random() * 3) + 3; // 3-5 √¥
                const cleanseIndices = [];
                while (cleanseIndices.length < cleanseCount) {
                    const idx = Math.floor(Math.random() * TOTAL_CELLS);
                    if (!eventIndices.includes(idx) && idx !== 0 && !cleanseIndices.includes(idx)) {
                        cleanseIndices.push(idx);
                        eventIndices.push(idx); // Th√™m v√†o eventIndices ƒë·ªÉ kh√¥ng b·ªã tr√πng
                    }
                }

                // T·∫°o 3-7 √¥ Gi·∫´m ƒë·∫°p ng·∫´u nhi√™n
                const killOnPathCount = Math.floor(Math.random() * 5) + 3; // 3-7 √¥
                const killOnPathIndices = [];
                while (killOnPathIndices.length < killOnPathCount) {
                    const idx = Math.floor(Math.random() * TOTAL_CELLS);
                    if (!eventIndices.includes(idx) && idx !== 0 && !killOnPathIndices.includes(idx)) {
                        killOnPathIndices.push(idx);
                        eventIndices.push(idx); // Th√™m v√†o eventIndices ƒë·ªÉ kh√¥ng b·ªã tr√πng
                    }
                }

                eventIndices.forEach(idx => {
                    let eventInfo;
                    if (portalList.includes(idx)) {
                        // Portal
                        eventInfo = { type: 'portal', icon: 'üåÄ', desc: 'Portal - ƒêi t·∫Øt sang portal ng·∫´u nhi√™n', category: 'movement' };
                    } else if (cleanseIndices.includes(idx)) {
                        // Thanh t·∫©y
                        eventInfo = { type: 'cleanse', icon: '‚ú®', desc: 'Thanh t·∫©y - L√†m tr·ªëng ng·∫´u nhi√™n x √¥ (x: 3-10)', category: 'attack' };
                    } else if (killOnPathIndices.includes(idx)) {
                        // Gi·∫´m ƒë·∫°p
                        eventInfo = { type: 'kill_on_path', icon: 'üíÄ', desc: 'Gi·∫´m ƒë·∫°p: Nh·ªØng √¥ ƒëi qua trong l∆∞·ª£t ƒë·ªï x√≠ ng·∫ßu ti·∫øp theo s·∫Ω ti√™u di·ªát nh·ªØng ng∆∞·ªùi ch∆°i b·ªã gi·∫´m qua', category: 'attack' };
                    } else {
                        eventInfo = eventTypes[Math.floor(Math.random() * eventTypes.length)];
                    }
                    
                    cells[idx].className = `cell event ${eventInfo.category}`;
                    cells[idx].textContent = eventInfo.icon;
                    cells[idx].dataset.type = 'event';
                    cells[idx].dataset.eventType = eventInfo.type;
                    cells[idx].dataset.tooltip = eventInfo.desc;
                    cells[idx].title = eventInfo.desc;
                    // ƒê·∫£m b·∫£o c√≥ data-cell-number ƒë·ªÉ hi·ªÉn th·ªã s·ªë th·ª© t·ª± (b·∫Øt ƒë·∫ßu t·ª´ 1)
                    if (!cells[idx].dataset.cellNumber) {
                        cells[idx].dataset.cellNumber = idx + 1;
                    }
                    eventData[idx] = eventInfo;
                    eventCells.push(idx);
                });
            } else {
                // Gi·ªØ l·∫°i event cells c≈©
                eventCells = oldEventIndices;
                eventData = oldEventData;
            }
            
            // L·∫•y danh s√°ch event indices hi·ªán t·∫°i
            const eventIndices = eventCells;

            // Ph√¢n b·ªï ng∆∞·ªùi ch∆°i v√†o c√°c √¥ c√≤n l·∫°i (tr·ª´ √¥ 0, event cells, v√† c√°c √¥ ƒë√£ tr√∫ng th∆∞·ªüng)
            const availableCells = [];
            for (let i = 1; i < TOTAL_CELLS; i++) {
                if (!eventIndices.includes(i) && cells[i].dataset.won !== 'true') {
                    availableCells.push(i);
                }
            }

            // Ph√¢n b·ªï t·∫•t c·∫£ players (kh√¥ng lo·∫°i tr·ª´ ng∆∞·ªùi ƒë√£ tr√∫ng, v√¨ h·ªç v·∫´n c√≥ th·ªÉ xu·∫•t hi·ªán ·ªü √¥ kh√°c)
            const eligiblePlayerIndices = [];
            for (let i = 0; i < originalPlayers.length; i++) {
                eligiblePlayerIndices.push(i);
            }

            if (eligiblePlayerIndices.length === 0) {
                return; // Kh√¥ng c√≤n ng∆∞·ªùi ch∆°i n√†o
            }

            // T√≠nh s·ªë l∆∞·ª£ng player c·∫ßn ph√¢n b·ªï theo giai ƒëo·∫°n
            // Ban ƒë·∫ßu: 33% ng∆∞·ªùi ch∆°i
            // Sau 5 l∆∞·ª£t: th√™m 33% n·ªØa (t·ªïng 66%)
            // Sau 10 l∆∞·ª£t: th√™m ph·∫ßn c√≤n l·∫°i (100%)
            let playerPercentage = 0.33; // 33% ban ƒë·∫ßu
            if (turnCount >= 10) {
                playerPercentage = 1.0; // 100% sau l∆∞·ª£t 10
            } else if (turnCount >= 5) {
                playerPercentage = 0.66; // 66% sau l∆∞·ª£t 5
            }
            
            const targetPlayerCount = Math.min(
                Math.max(
                    Math.floor(eligiblePlayerIndices.length * playerPercentage),
                    1 // T·ªëi thi·ªÉu 1 ng∆∞·ªùi ch∆°i
                ),
                availableCells.length
            );

            const playerIndices = [];
            const usedCells = new Set();
            
            // Ph√¢n b·ªï player v·ªõi kh·∫£ nƒÉng l·∫∑p l·∫°i
            const availableCellsCopy = [...availableCells];
            for (let i = 0; i < targetPlayerCount && availableCellsCopy.length > 0; i++) {
                const randomPlayerIdx = eligiblePlayerIndices[Math.floor(Math.random() * eligiblePlayerIndices.length)];
                const randomCellIdx = Math.floor(Math.random() * availableCellsCopy.length);
                const cellIdx = availableCellsCopy[randomCellIdx];
                
                if (!usedCells.has(cellIdx)) {
                    playerIndices.push({ cellIdx, playerIdx: randomPlayerIdx });
                    usedCells.add(cellIdx);
                    availableCellsCopy.splice(randomCellIdx, 1);
                }
            }

            // L∆∞u mapping gi·ªØa cell index v√† player index (cho ph√©p nhi·ªÅu cell c√πng player)
            playerCellMap.clear();
            playerIndices.forEach(({ cellIdx, playerIdx }) => {
                // Ki·ªÉm tra xem player n√†y c√≥ b·ªã ch·∫øt ·ªü cell n√†y kh√¥ng (m·ªói cell ƒë·ªôc l·∫≠p)
                const cellKey = `${cellIdx}_${playerIdx}`;
                const isDead = deadPlayers.has(cellKey) || deadPlayers.has(playerIdx);
                const isWon = cells[cellIdx].dataset.won === 'true';
                
                // N·∫øu √¥ ƒë√£ tr√∫ng th∆∞·ªüng, gi·ªØ nguy√™n class winner
                if (isWon) {
                    cells[cellIdx].classList.add('player', 'winner');
                } else {
                    cells[cellIdx].className = isDead ? 'cell player dead' : 'cell player';
                }
                
                // Hi·ªÉn th·ªã ƒë·∫ßy ƒë·ªß t√™n, cho ph√©p xu·ªëng h√†ng
                let playerName = originalPlayers[playerIdx];
                cells[cellIdx].textContent = playerName;
                cells[cellIdx].title = originalPlayers[playerIdx];
                cells[cellIdx].dataset.type = 'player';
                cells[cellIdx].dataset.playerIndex = playerIdx;
                cells[cellIdx].dataset.cellKey = cellKey; // L∆∞u key ƒë·ªÉ x·ª≠ l√Ω ƒë·ªôc l·∫≠p
                playerCellMap.set(cellIdx, playerIdx);
            });
        }


        // T·ª± ƒë·ªông ƒë√°nh s·ªë danh s√°ch trong textarea
        function autoNumberList(textarea, preserveCursor = false) {
            const cursorPos = textarea.selectionStart;
            const lines = textarea.value.split('\n');
            let newCursorPos = cursorPos;
            
            const numberedLines = lines.map((line, index) => {
                const trimmed = line.trim();
                if (!trimmed) return '';
                
                // Ki·ªÉm tra xem ƒë√£ c√≥ s·ªë ch∆∞a
                const match = trimmed.match(/^(\d+)\.\s*(.*)$/);
                if (match) {
                    const oldNum = match[1];
                    const content = match[2];
                    const newNum = index + 1;
                    if (oldNum !== String(newNum)) {
                        // ƒêi·ªÅu ch·ªânh v·ªã tr√≠ con tr·ªè n·∫øu c·∫ßn
                        if (preserveCursor && cursorPos > textarea.value.indexOf(line)) {
                            const lineStart = textarea.value.indexOf(line);
                            const offset = String(newNum).length - oldNum.length;
                            if (cursorPos >= lineStart && cursorPos <= lineStart + line.length) {
                                newCursorPos += offset;
                            }
                        }
                        return `${newNum}. ${content}`;
                    }
                    return trimmed;
                }
                return `${index + 1}. ${trimmed}`;
            });
            
            textarea.value = numberedLines.join('\n');
            if (preserveCursor) {
                textarea.setSelectionRange(newCursorPos, newCursorPos);
            }
        }

        // Ki·ªÉm tra v√† enable/disable n√∫t b·∫Øt ƒë·∫ßu
        function checkStartButton() {
            const playersInput = document.getElementById('playersInput').value.trim();
            const prizesInput = document.getElementById('prizesInput').value.trim();
            const startBtn = document.getElementById('startBtn');
            const diceBtn = document.getElementById('diceBtn');

            // N·∫øu game ƒë√£ b·∫Øt ƒë·∫ßu, gi·ªØ n√∫t b·∫Øt ƒë·∫ßu ·ªü tr·∫°ng th√°i ch√¨m
            if (gameStarted) {
                startBtn.disabled = true;
                startBtn.style.opacity = '0.3';
                startBtn.style.cursor = 'not-allowed';
                startBtn.style.transform = 'scale(0.95)';
            } else {
                // N·∫øu game ch∆∞a b·∫Øt ƒë·∫ßu, ki·ªÉm tra input ƒë·ªÉ enable/disable
                if (playersInput && prizesInput) {
                    startBtn.disabled = false;
                    startBtn.style.opacity = '1';
                    startBtn.style.cursor = 'pointer';
                    startBtn.style.transform = 'scale(1)';
                } else {
                    startBtn.disabled = true;
                    startBtn.style.opacity = '0.5';
                    startBtn.style.cursor = 'not-allowed';
                    startBtn.style.transform = 'scale(1)';
                }
            }
            
            // N√∫t Nh√¢n Ph·∫©m lu√¥n hi·ªÉn th·ªã, ch·ªâ thay ƒë·ªïi tr·∫°ng th√°i enabled/disabled
            diceBtn.style.display = 'block';
            if (!gameStarted) {
                // N·∫øu game ch∆∞a b·∫Øt ƒë·∫ßu, n√∫t b·ªã ch√¨m (disabled)
                diceBtn.disabled = true;
                diceBtn.style.opacity = '0.3';
                diceBtn.style.cursor = 'not-allowed';
                diceBtn.style.transform = 'scale(0.95)';
            } else {
                // N·∫øu game ƒë√£ b·∫Øt ƒë·∫ßu, n√∫t n·ªïi l√™n (enabled)
                diceBtn.disabled = false;
                diceBtn.style.opacity = '1';
                diceBtn.style.cursor = 'pointer';
                diceBtn.style.transform = 'scale(1)';
            }
        }

        // X·ª≠ l√Ω upload ·∫£nh
        document.getElementById('avatarUpload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    avatarImage = e.target.result;
                    // Kh√¥ng hi·ªÉn th·ªã ·∫£nh preview ƒë·ªÉ ti·∫øt ki·ªám di·ªán t√≠ch
                    saveGameData(); // L∆∞u d·ªØ li·ªáu khi upload avatar
                };
                reader.readAsDataURL(file);
            } else {
                avatarImage = null;
                saveGameData(); // L∆∞u d·ªØ li·ªáu khi x√≥a avatar
            }
        });

        // L·∫Øng nghe thay ƒë·ªïi input
        document.getElementById('playersInput').addEventListener('input', function() {
            checkStartButton();
            saveGameData();
        });
        document.getElementById('playersInput').addEventListener('blur', function() {
            autoNumberList(this, false);
            saveGameData();
        });
        
        document.getElementById('prizesInput').addEventListener('input', function() {
            checkStartButton();
            saveGameData();
        });
        document.getElementById('prizesInput').addEventListener('blur', function() {
            autoNumberList(this, false);
            saveGameData();
        });

        // B·∫Øt ƒë·∫ßu game
        document.getElementById('startBtn').addEventListener('click', function() {
            let playersInput = document.getElementById('playersInput').value.trim();
            let prizesInput = document.getElementById('prizesInput').value.trim();

            // Lo·∫°i b·ªè s·ªë th·ª© t·ª± v√† d·∫•u sao n·∫øu c√≥
            originalPlayers = playersInput.split('\n')
                .filter(p => p.trim())
                .map(p => p.replace(/^\d+\.\s*/, '').replace(/‚≠ê\s*/, '').trim());
            originalPrizes = prizesInput.split('\n')
                .filter(p => p.trim())
                .map(p => p.replace(/^\d+\.\s*/, '').trim());
            players = [...originalPlayers];
            prizes = [...originalPrizes];

            if (originalPlayers.length === 0 || originalPrizes.length === 0) {
                alert('Vui l√≤ng nh·∫≠p √≠t nh·∫•t 1 ng∆∞·ªùi ch∆°i v√† 1 ph·∫ßn th∆∞·ªüng!');
                return;
            }

            currentPosition = 0;
            gameStarted = true;
            deadPlayers = new Set();
            playerShields = {};
            playerWinners = new Set();
            gameHistory = [];
            turnCount = 0;
            roundCount = 0;
            playerRepeatMultiplier = 1;
            eventMultiplier = 1;
            lastWinTurn = 0;
            playerCellMap = new Map();
            document.getElementById('historyContainer').innerHTML = '';
            initGrid(); // Kh·ªüi t·∫°o l·∫°i grid v·ªõi k√≠ch th∆∞·ªõc m·ªõi
            distributePlayers(true);
            createGamePiece();
            
            // Enable n√∫t Nh√¢n Ph·∫©m (n·ªïi l√™n) v√† l√†m ch√¨m n√∫t b·∫Øt ƒë·∫ßu
            const diceBtn = document.getElementById('diceBtn');
            diceBtn.disabled = false;
            diceBtn.style.opacity = '1';
            diceBtn.style.cursor = 'pointer';
            diceBtn.style.transform = 'scale(1)';
            const startBtn = document.getElementById('startBtn');
            startBtn.disabled = true;
            startBtn.style.opacity = '0.3';
            startBtn.style.cursor = 'not-allowed';
            startBtn.style.transform = 'scale(0.95)';
            
            addToHistory('üéÆ B·∫Øt ƒë·∫ßu game!', false);
            saveGameData(); // L∆∞u d·ªØ li·ªáu khi b·∫Øt ƒë·∫ßu game
        });

        // N√∫t gieo x√∫c x·∫Øc th·ªß c√¥ng
        document.getElementById('diceBtn').addEventListener('click', function() {
            if (!isMoving && prizes.length > 0) {
                this.disabled = true;
                rollDice();
            }
        });

        // T·∫°o qu√¢n c·ªù
        function createGamePiece() {
            // X√≥a qu√¢n c·ªù c≈© n·∫øu c√≥
            if (gamePiece) {
                gamePiece.remove();
            }

            gamePiece = document.createElement('div');
            gamePiece.className = 'game-piece';
            
            if (avatarImage) {
                const img = document.createElement('img');
                img.src = avatarImage;
                gamePiece.appendChild(img);
            } else {
                // S·ª≠ d·ª•ng ·∫£nh m·∫∑c ƒë·ªãnh ho·∫∑c icon
                const img = document.createElement('img');
                img.src = 'https://media.nguyez.com/IMG/AVT-NguyeZGaming.png';
                img.onerror = function() {
                    // N·∫øu ·∫£nh kh√¥ng load ƒë∆∞·ª£c, d√πng emoji
                    this.style.display = 'none';
                    gamePiece.textContent = 'üéÆ';
                    gamePiece.style.fontSize = '40px';
                };
                gamePiece.appendChild(img);
            }

            const firstCell = cells[0];
            firstCell.appendChild(gamePiece);
            firstCell.classList.add('current');
        }

        // X√∫c x·∫Øc
        function rollDice() {
            const diceContainer = document.getElementById('diceContainer');
            const diceResult = document.getElementById('diceResult');
            const diceBtn = document.getElementById('diceBtn');
            
            hasTeleported = false; // Reset flag portal khi b·∫Øt ƒë·∫ßu l∆∞·ª£t m·ªõi
            // Kh√¥ng reset shouldKillOnPath ·ªü ƒë√¢y v√¨ n√≥ ch·ªâ √°p d·ª•ng cho l∆∞·ª£t ti·∫øp theo
            diceContainer.classList.add('active');
            diceResult.textContent = 'ƒêang x√∫c x·∫Øc...';

            // Animation x√∫c x·∫Øc
            let rollCount = 0;
            const maxRolls = 15;
            const rollInterval = setInterval(() => {
                rollCount++;
                const randomValue = Math.floor(Math.random() * 21) + 1;
                diceResult.textContent = `üé≤ ${randomValue}`;
                
                if (rollCount >= maxRolls) {
                    clearInterval(rollInterval);
                    const diceValue = Math.floor(Math.random() * 21) + 1; // 1-21
                    diceResult.textContent = `K·∫øt qu·∫£: ${diceValue}`;
                    
                    // Th√™m v√†o l·ªãch s·ª≠ (tƒÉng l∆∞·ª£t)
                    addToHistory(`üé≤ Gieo x√∫c x·∫Øc: ${diceValue}`, true);
                    playSound('dice');
                    
                    // C·∫≠p nh·∫≠t countdown
                    updateLuckyCountdown();
                    
                    // T·ª± ƒë·ªông th√™m ng∆∞·ªùi ch∆°i ·ªü l∆∞·ª£t 5 v√† 10
                    if (turnCount === 5) {
                        distributePlayers(false);
                        addToHistory(`üìä ƒê√£ th√™m ng∆∞·ªùi ch∆°i ƒë·∫øn 66% t·ªïng s·ªë ng∆∞·ªùi ch∆°i!`, false);
                        updateStages(); // C·∫≠p nh·∫≠t giai ƒëo·∫°n 2
                    } else if (turnCount === 10) {
                        distributePlayers(false);
                        addToHistory(`üìä ƒê√£ th√™m ng∆∞·ªùi ch∆°i ƒë·∫øn 100% t·ªïng s·ªë ng∆∞·ªùi ch∆°i!`, false);
                        updateStages(); // C·∫≠p nh·∫≠t giai ƒëo·∫°n 3
                    }
                    
                    // Ki·ªÉm tra xem t·∫•t c·∫£ √¥ ƒë√£ c√≥ t√™n ng∆∞·ªùi ch∆°i ch∆∞a (tr·ª´ √¥ 0)
                    if (!hasPerformedFullCleanse) {
                        let allCellsHavePlayers = true;
                        for (let i = 1; i < TOTAL_CELLS; i++) {
                            if (cells[i].dataset.type !== 'player' || cells[i].dataset.won === 'true') {
                                allCellsHavePlayers = false;
                                break;
                            }
                        }
                        
                        if (allCellsHavePlayers) {
                            // Th·ª±c hi·ªán thanh t·∫©y 10 √¥ ng·∫´u nhi√™n
                            hasPerformedFullCleanse = true;
                            performFullCleanse();
                            updateStages(); // C·∫≠p nh·∫≠t giai ƒëo·∫°n
                        }
                    }
                    
                    // Ki·ªÉm tra v√† tƒÉng c∆° h·ªôi sau m·ªói 7 l∆∞·ª£t gieo x√≠ ng·∫ßu (ch·ªâ sau l∆∞·ª£t 10)
                    if (turnCount > 10 && turnCount % 7 === 0) {
                        // Ch·ªçn ng·∫´u nhi√™n 25% ng∆∞·ªùi ch∆°i (l√†m tr√≤n l√™n) v√† th√™m v√†o c√°c √¥ tr·ªëng
                        const eligiblePlayers = [];
                        for (let i = 0; i < originalPlayers.length; i++) {
                            eligiblePlayers.push(i);
                        }
                        
                        if (eligiblePlayers.length > 0) {
                            const luckyCount = Math.ceil(eligiblePlayers.length * 0.25);
                            const luckyPlayers = [];
                            const shuffled = [...eligiblePlayers].sort(() => Math.random() - 0.5);
                            
                            for (let i = 0; i < luckyCount && i < shuffled.length; i++) {
                                luckyPlayers.push(shuffled[i]);
                            }
                            
                            // T√¨m c√°c √¥ tr·ªëng ƒë·ªÉ th√™m ng∆∞·ªùi ch∆°i may m·∫Øn (kh√¥ng c√≥ player, event, ho·∫∑c ƒë√£ tr√∫ng th∆∞·ªüng)
                            const emptyCells = [];
                            for (let i = 1; i < TOTAL_CELLS; i++) {
                                const cellType = cells[i].dataset.type;
                                if ((cellType === '' || cellType === 'empty') && 
                                    !eventCells.includes(i) && 
                                    cells[i].dataset.won !== 'true' &&
                                    cellType !== 'player') {
                                    emptyCells.push(i);
                                }
                            }
                            
                            // Th√™m ng∆∞·ªùi ch∆°i may m·∫Øn v√†o c√°c √¥ tr·ªëng
                            let addedCount = 0;
                            const shuffledEmptyCells = [...emptyCells].sort(() => Math.random() - 0.5);
                            
                            for (let i = 0; i < Math.min(luckyPlayers.length, shuffledEmptyCells.length); i++) {
                                const cellIdx = shuffledEmptyCells[i];
                                const playerIdx = luckyPlayers[i];
                                const cellKey = `${cellIdx}_${playerIdx}`;
                                
                                // Ki·ªÉm tra l·∫°i xem cell n√†y c√≥ tr·ªëng kh√¥ng
                                const cellType = cells[cellIdx].dataset.type;
                                if ((cellType === '' || cellType === 'empty') && 
                                    !eventCells.includes(cellIdx) && 
                                    cells[cellIdx].dataset.won !== 'true') {
                                    cells[cellIdx].className = 'cell player';
                                    let playerName = originalPlayers[playerIdx];
                                    cells[cellIdx].textContent = playerName;
                                    cells[cellIdx].title = originalPlayers[playerIdx];
                                    cells[cellIdx].dataset.type = 'player';
                                    cells[cellIdx].dataset.playerIndex = playerIdx;
                                    cells[cellIdx].dataset.cellKey = cellKey;
                                    playerCellMap.set(cellIdx, playerIdx);
                                    addedCount++;
                                }
                            }
                            
                            if (addedCount > 0) {
                                // Ghi v√†o l·ªãch s·ª≠ v·ªõi th√¥ng tin chi ti·∫øt
                                const addedPlayers = [];
                                for (let i = 0; i < addedCount; i++) {
                                    const cellIdx = shuffledEmptyCells[i];
                                    const playerIdx = luckyPlayers[i];
                                    const playerName = originalPlayers[playerIdx];
                                    const cellNumber = cellIdx + 1;
                                    addedPlayers.push(`${playerName} (√¥ ${cellNumber})`);
                                }
                                const luckyMessage = `üçÄ Sau ${turnCount} l∆∞·ª£t gieo x√≠ ng·∫ßu! ${addedCount} ng∆∞·ªùi ch∆°i may m·∫Øn ƒë∆∞·ª£c th√™m v√†o: ${addedPlayers.join(', ')}`;
                                showEvent(luckyMessage);
                                addToHistory(luckyMessage, false);
                                updateStages(); // C·∫≠p nh·∫≠t giai ƒëo·∫°n may m·∫Øn
                                saveGameData();
                            }
                        }
                    }
                    
                    setTimeout(() => {
                        diceContainer.classList.remove('active');
                        isMoving = true;
                        // Ki·ªÉm tra n·∫øu c·∫ßn l√πi
                        if (shouldMoveBackward) {
                            movePiece(-diceValue);
                            shouldMoveBackward = false; // Reset flag sau khi l√πi
                        } else {
                            movePiece(diceValue);
                        }
                    }, 1800);
                }
            }, 80);
        }

        // H√†m t√≠nh v·ªã tr√≠ v·ªõi v√≤ng l·∫∑p (0 ƒë·∫øn TOTAL_CELLS-1)
        function normalizePosition(pos) {
            if (pos >= TOTAL_CELLS) {
                return pos % TOTAL_CELLS;
            } else if (pos < 0) {
                return ((pos % TOTAL_CELLS) + TOTAL_CELLS) % TOTAL_CELLS;
            }
            return pos;
        }

        // Di chuy·ªÉn qu√¢n c·ªù
        function movePiece(steps) {
            const startPosition = currentPosition;
            const totalSteps = Math.abs(steps);
            const direction = steps > 0 ? 1 : -1;
            
            // T√≠nh v·ªã tr√≠ ƒë√≠ch v·ªõi v√≤ng l·∫∑p
            let targetPosition = normalizePosition(startPosition + steps);
            
            let stepsTaken = 0;

            // Di chuy·ªÉn ƒë·∫øn t·ª´ng √¥
            const moveInterval = setInterval(() => {
                stepsTaken++;
                let nextPos = startPosition + (stepsTaken * direction);
                nextPos = normalizePosition(nextPos);
                
                if (stepsTaken <= totalSteps) {
                    // X√≥a class current kh·ªèi √¥ c≈©
                    if (stepsTaken === 1) {
                        cells[startPosition].classList.remove('current');
                        cells[startPosition].classList.add('visited');
                    } else {
                        let prevPos = startPosition + ((stepsTaken - 1) * direction);
                        prevPos = normalizePosition(prevPos);
                        cells[prevPos].classList.remove('current');
                    }
                    
                    // Di chuy·ªÉn qu√¢n c·ªù
                    if (gamePiece) {
                        const targetCell = cells[nextPos];
                        if (gamePiece.parentNode !== targetCell) {
                            // X√≥a kh·ªèi √¥ c≈©
                            if (gamePiece.parentNode) {
                                gamePiece.parentNode.removeChild(gamePiece);
                            }
                            // Th√™m v√†o √¥ m·ªõi
                            targetCell.appendChild(gamePiece);
                        }
                        // ƒê·∫£m b·∫£o v·ªã tr√≠ ƒë√∫ng
                        gamePiece.style.top = '50%';
                        gamePiece.style.left = '50%';
                        
                        // Ph√°t √¢m thanh khi di chuy·ªÉn
                        playSound('move');
                    }
                    
                    cells[nextPos].classList.add('current');
                    cells[nextPos].classList.add('visited');

                    // N·∫øu c√≥ flag shouldKillOnPath, ti√™u di·ªát ng∆∞·ªùi ch∆°i khi ƒëi qua
                    if (shouldKillOnPath && cells[nextPos].dataset.type === 'player' && !cells[nextPos].classList.contains('dead')) {
                        const pIdx = parseInt(cells[nextPos].dataset.playerIndex);
                        const cellKey = cells[nextPos].dataset.cellKey;
                        if (!playerWinners.has(pIdx) && !deadPlayers.has(cellKey) && !deadPlayers.has(pIdx)) {
                            killPlayer(pIdx, nextPos);
                            playSound('kill');
                        }
                    }

                    // Scroll ƒë·∫øn √¥ hi·ªán t·∫°i
                    cells[nextPos].scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // C·∫≠p nh·∫≠t v·ªã tr√≠ hi·ªán t·∫°i
                    currentPosition = nextPos;
                    
                    // Ki·ªÉm tra ƒë√£ ƒë·∫øn ƒë√≠ch ch∆∞a
                    if (stepsTaken === totalSteps) {
                        clearInterval(moveInterval);
                        // Reset flag sau khi di chuy·ªÉn xong
                        if (shouldKillOnPath) {
                            shouldKillOnPath = false;
                        }
                        setTimeout(() => {
                            handleCellLanding(targetPosition);
                        }, 300);
                    }
                } else {
                    clearInterval(moveInterval);
                        // Reset flag sau khi di chuy·ªÉn xong
                        if (shouldKillOnPath) {
                            shouldKillOnPath = false;
                            addToHistory('üíÄ ƒê√£ k·∫øt th√∫c hi·ªáu ·ª©ng ti√™u di·ªát ng∆∞·ªùi ch∆°i khi ƒëi qua!', false);
                        }
                    setTimeout(() => {
                        handleCellLanding(currentPosition);
                    }, 300);
                }
            }, 200);
        }

        // X·ª≠ l√Ω khi qu√¢n c·ªù d·ª´ng ·ªü m·ªôt √¥
        function handleCellLanding(position) {
            const cell = cells[position];
            const cellType = cell.dataset.type;
            const diceBtn = document.getElementById('diceBtn');

            // Qu√¢n c·ªù c√≥ th·ªÉ ƒëi qua √¥ player ƒë√£ ch·∫øt, ch·ªâ x·ª≠ l√Ω n·∫øu l√† player c√≤n s·ªëng
            if (cellType === 'player' && !cell.classList.contains('dead')) {
                const playerIndex = parseInt(cell.dataset.playerIndex);
                const existingCellKey = cell.dataset.cellKey;
                const isDead = deadPlayers.has(existingCellKey) || deadPlayers.has(playerIndex);
                const isWon = cell.dataset.won === 'true';
                
                if (!isDead && !isWon && prizes.length > 0) {
                    const player = originalPlayers[playerIndex];
                    const prize = prizes.shift();

                    // ƒê√°nh d·∫•u ng∆∞·ªùi ch∆°i ƒë√£ tr√∫ng th∆∞·ªüng (ch·ªâ ƒë√°nh d·∫•u cell n√†y, kh√¥ng x√≥a)
                    const wonCellKey = `${position}_${playerIndex}`;
                    playerWinners.add(wonCellKey); // L∆∞u cellKey ƒë·ªÉ ƒë√°nh d·∫•u cell c·ª• th·ªÉ ƒë√£ tr√∫ng
                    lastWinTurn = turnCount;
                    playerRepeatMultiplier = 1; // Reset multiplier khi c√≥ ng∆∞·ªùi tr√∫ng
                    eventMultiplier = 1;

                    // ƒê√°nh d·∫•u √¥ n√†y l√† winner nh∆∞ng v·∫´n gi·ªØ t√™n v√† class player
                    cell.classList.add('winner');
                    cell.dataset.won = 'true'; // ƒê√°nh d·∫•u √¥ n√†y ƒë√£ tr√∫ng th∆∞·ªüng

                    // Th√™m v√†o k·∫øt qu·∫£
                    addResult(player, prize, playerIndex);
                    playSound('win');

                    // C·∫≠p nh·∫≠t textarea (ƒë√°nh d·∫•u sao nh∆∞ng kh√¥ng x√≥a)
                    updateTextareaAfterWin();

                    // K√≠ch ho·∫°t l·∫°i n√∫t gieo x√∫c x·∫Øc
                    isMoving = false;
                    diceBtn.disabled = false;

                    // Ki·ªÉm tra ƒëi·ªÅu ki·ªán ti·∫øp t·ª•c
                    if (prizes.length === 0) {
                        setTimeout(() => {
                            showEvent('üéâ ƒê√£ trao h·∫øt ph·∫ßn th∆∞·ªüng!');
                            diceBtn.style.display = 'none';
                        }, 2000);
                    }
                } else if (cell.dataset.won === 'true') {
                    // √î n√†y ƒë√£ tr√∫ng th∆∞·ªüng r·ªìi, kh√¥ng trao th∆∞·ªüng n·ªØa
                    isMoving = false;
                    diceBtn.disabled = false;
                } else {
                    isMoving = false;
                    diceBtn.disabled = false;
                }
            } else if (cellType === 'event') {
                // X·ª≠ l√Ω event
                handleEvent(position);
            } else {
                // √î tr·ªëng ho·∫∑c √¥ player ƒë√£ ch·∫øt
                isMoving = false;
                diceBtn.disabled = false;
                
                // Ki·ªÉm tra n·∫øu t·∫•t c·∫£ ng∆∞·ªùi ch∆°i ƒë√£ ch·∫øt
                checkAndRevivePlayers();
                
                if (prizes.length === 0) {
                    showEvent('üéâ ƒê√£ trao h·∫øt ph·∫ßn th∆∞·ªüng!');
                    diceBtn.style.display = 'none';
                }
            }
        }

        // Ki·ªÉm tra v√† h·ªìi sinh ng∆∞·ªùi ch∆°i n·∫øu t·∫•t c·∫£ ƒë√£ ch·∫øt
        function checkAndRevivePlayers() {
            // ƒê·∫øm s·ªë ng∆∞·ªùi ch∆°i c√≤n s·ªëng
            let aliveCount = 0;
            for (let i = 0; i < cells.length; i++) {
                if (cells[i].dataset.type === 'player' && !cells[i].classList.contains('dead')) {
                    const pIdx = parseInt(cells[i].dataset.playerIndex);
                    const cellKey = cells[i].dataset.cellKey;
                    if (!deadPlayers.has(cellKey) && !deadPlayers.has(pIdx) && !playerWinners.has(pIdx)) {
                        aliveCount++;
                    }
                }
            }

            if (aliveCount === 0 && prizes.length > 0) {
                // H·ªìi sinh ng·∫´u nhi√™n (tr·ª´ ng∆∞·ªùi ƒë√£ tr√∫ng)
                const eligiblePlayers = [];
                for (let i = 0; i < originalPlayers.length; i++) {
                    if (!playerWinners.has(i)) {
                        eligiblePlayers.push(i);
                    }
                }

                if (eligiblePlayers.length > 0) {
                    // X√≥a t·∫•t c·∫£ dead markers
                    deadPlayers.clear();
                    
                    // TƒÉng event cells v√† player repeat
                    eventMultiplier = Math.min(eventMultiplier + 0.5, 2);
                    playerRepeatMultiplier = Math.min(playerRepeatMultiplier + 1, 5);
                    
                    // X√≥a event cells c≈© v√† t·∫°o l·∫°i
                    eventCells = [];
                    eventData = {};
                    
                    // T·∫°o l·∫°i event cells v·ªõi multiplier m·ªõi
                    const baseEvents = Math.floor(Math.random() * (TOTAL_CELLS * 0.3)) + Math.floor(TOTAL_CELLS * 0.25);
                    const numEvents = Math.min(Math.floor(baseEvents * eventMultiplier), Math.floor(TOTAL_CELLS * 0.5));
                    const newEventIndices = [];
                    while (newEventIndices.length < numEvents) {
                        const idx = Math.floor(Math.random() * TOTAL_CELLS);
                        if (!newEventIndices.includes(idx) && idx !== 0) {
                            newEventIndices.push(idx);
                        }
                    }
                    
                    // ƒê·ªãnh nghƒ©a c√°c lo·∫°i event (tƒÉng g·∫•p ƒë√¥i t·∫ßn su·∫•t attack)
                    const movementEvents = [
                        { type: 'move_forward', icon: '‚¨ÜÔ∏è', desc: 'Ti·∫øn th√™m 1-5 √¥', category: 'movement' },
                        { type: 'move_backward', icon: '‚¨áÔ∏è', desc: 'L√πi x √¥ (l√πi ·ªü l·∫ßn gieo x√≠ ng·∫ßu ti·∫øp theo)', category: 'movement' },
                        { type: 'jump_row', icon: '‚¨áÔ∏è', desc: 'Nh·∫£y xu·ªëng h√†ng d·ªçc: Nh·∫£y xu·ªëng h√†ng d∆∞·ªõi', category: 'movement' },
                    ];
                    
                    const attackEvents = [
                        { type: 'kill_random', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát 1 ƒë·∫øn 5 ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n', category: 'attack' },
                        { type: 'kill_nearest', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát 1 ƒë·∫øn 5 ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t', category: 'attack' },
                        { type: 'bomb_row', icon: 'üí£', desc: 'Bom h√†ng ngang', category: 'attack' },
                        { type: 'bomb_col', icon: 'üí£', desc: 'Bom h√†ng d·ªçc', category: 'attack' },
                        { type: 'bomb_cross', icon: 'üí•', desc: 'Bom ch·ªØ th·∫≠p (ngang + d·ªçc)', category: 'attack' },
                        { type: 'bouncing_bomb', icon: 'üí£üí•', desc: 'Bom n·∫£y - n·ªï x l·∫ßn m·ªói 2-3 √¥', category: 'attack' },
                        // Duplicate ƒë·ªÉ tƒÉng g·∫•p ƒë√¥i t·∫ßn su·∫•t
                        { type: 'kill_random', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát 1 ƒë·∫øn 5 ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n', category: 'attack' },
                        { type: 'kill_nearest', icon: '‚öîÔ∏è', desc: 'Ti√™u di·ªát 1 ƒë·∫øn 5 ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t', category: 'attack' },
                        { type: 'bomb_row', icon: 'üí£', desc: 'Bom h√†ng ngang', category: 'attack' },
                        { type: 'bomb_col', icon: 'üí£', desc: 'Bom h√†ng d·ªçc', category: 'attack' },
                        { type: 'bomb_cross', icon: 'üí•', desc: 'Bom ch·ªØ th·∫≠p (ngang + d·ªçc)', category: 'attack' },
                        { type: 'bouncing_bomb', icon: 'üí£üí•', desc: 'Bom n·∫£y - n·ªï x l·∫ßn m·ªói 2-3 √¥', category: 'attack' }
                    ];
                    
                    // Th√™m s·ª± ki·ªán Thanh t·∫©y v√†o nh√≥m t·∫•n c√¥ng
                    attackEvents.push(
                        { type: 'cleanse', icon: '‚ú®', desc: 'Thanh t·∫©y - L√†m tr·ªëng ng·∫´u nhi√™n x √¥ (x: 3-10)', category: 'attack' }
                    );
                    
                    const eventTypes = [...movementEvents, ...attackEvents];
                    
                    // T·∫°o 5 portal ng·∫´u nhi√™n
                    portalList = [];
                    const portalIndices = [];
                    while (portalIndices.length < 5) {
                        const idx = Math.floor(Math.random() * TOTAL_CELLS);
                        if (!newEventIndices.includes(idx) && idx !== 0 && !portalIndices.includes(idx)) {
                            portalIndices.push(idx);
                            newEventIndices.push(idx);
                        }
                    }
                    portalList = portalIndices;

                    // T·∫°o 3-5 √¥ thanh t·∫©y ng·∫´u nhi√™n
                    const cleanseCount = Math.floor(Math.random() * 3) + 3; // 3-5 √¥
                    const cleanseIndices = [];
                    while (cleanseIndices.length < cleanseCount) {
                        const idx = Math.floor(Math.random() * TOTAL_CELLS);
                        if (!newEventIndices.includes(idx) && idx !== 0 && !cleanseIndices.includes(idx)) {
                            cleanseIndices.push(idx);
                            newEventIndices.push(idx);
                        }
                    }

                    // T·∫°o 3-7 √¥ Gi·∫´m ƒë·∫°p ng·∫´u nhi√™n
                    const killOnPathCount = Math.floor(Math.random() * 5) + 3; // 3-7 √¥
                    const killOnPathIndices = [];
                    while (killOnPathIndices.length < killOnPathCount) {
                        const idx = Math.floor(Math.random() * TOTAL_CELLS);
                        if (!newEventIndices.includes(idx) && idx !== 0 && !killOnPathIndices.includes(idx)) {
                            killOnPathIndices.push(idx);
                            newEventIndices.push(idx);
                        }
                    }
                    
                    // T·∫°o event cells
                    newEventIndices.forEach(idx => {
                        let eventInfo;
                        if (portalList.includes(idx)) {
                            eventInfo = { type: 'portal', icon: 'üåÄ', desc: 'Portal - ƒêi t·∫Øt sang portal ng·∫´u nhi√™n', category: 'movement' };
                        } else if (cleanseIndices.includes(idx)) {
                            // Thanh t·∫©y
                            eventInfo = { type: 'cleanse', icon: '‚ú®', desc: 'Thanh t·∫©y - L√†m tr·ªëng ng·∫´u nhi√™n x √¥ (x: 3-10)', category: 'attack' };
                        } else if (killOnPathIndices.includes(idx)) {
                            // Gi·∫´m ƒë·∫°p
                            eventInfo = { type: 'kill_on_path', icon: 'üíÄ', desc: 'Gi·∫´m ƒë·∫°p: Nh·ªØng √¥ ƒëi qua trong l∆∞·ª£t ƒë·ªï x√≠ ng·∫ßu ti·∫øp theo s·∫Ω ti√™u di·ªát nh·ªØng ng∆∞·ªùi ch∆°i b·ªã gi·∫´m qua', category: 'attack' };
                        } else {
                            eventInfo = eventTypes[Math.floor(Math.random() * eventTypes.length)];
                        }
                        
                        cells[idx].className = `cell event ${eventInfo.category}`;
                        cells[idx].textContent = eventInfo.icon;
                        cells[idx].dataset.type = 'event';
                        cells[idx].dataset.eventType = eventInfo.type;
                        cells[idx].dataset.tooltip = eventInfo.desc;
                        cells[idx].title = eventInfo.desc;
                        // ƒê·∫£m b·∫£o c√≥ data-cell-number ƒë·ªÉ hi·ªÉn th·ªã s·ªë th·ª© t·ª±
                        cells[idx].dataset.cellNumber = idx + 1;
                        eventData[idx] = eventInfo;
                        eventCells.push(idx);
                    });
                    
                    // Ph√¢n b·ªï l·∫°i players
                    const savedPosition = currentPosition;
                    distributePlayers(false);
                    currentPosition = savedPosition;
                    
                    // ƒê·∫£m b·∫£o qu√¢n c·ªù v·∫´n ·ªü v·ªã tr√≠ hi·ªán t·∫°i
                    if (gamePiece && gamePiece.parentNode) {
                        gamePiece.parentNode.removeChild(gamePiece);
                    }
                    if (cells[currentPosition]) {
                        cells[currentPosition].appendChild(gamePiece);
                        cells[currentPosition].classList.add('current');
                    }
                    
                    showEvent('üîÑ T·∫•t c·∫£ ng∆∞·ªùi ch∆°i ƒë√£ h·ªìi sinh! C∆° h·ªôi tƒÉng l√™n!');
                    playSound('event');
                }
            }
        }

        // C·∫≠p nh·∫≠t textarea sau khi c√≥ ng∆∞·ªùi tr√∫ng th∆∞·ªüng
        function updateTextareaAfterWin() {
            // C·∫≠p nh·∫≠t danh s√°ch ng∆∞·ªùi ch∆°i - ƒë√°nh d·∫•u sao cho ng∆∞·ªùi ƒë√£ tr√∫ng nh∆∞ng kh√¥ng x√≥a
            const playersTextarea = document.getElementById('playersInput');
            const lines = playersTextarea.value.split('\n');
            const updatedLines = lines.map((line, index) => {
                const trimmed = line.trim();
                if (!trimmed) return '';
                
                // Lo·∫°i b·ªè s·ªë th·ª© t·ª± v√† d·∫•u sao n·∫øu c√≥
                const cleanLine = trimmed.replace(/^\d+\.\s*/, '').replace(/‚≠ê\s*/, '').trim();
                const playerIndex = originalPlayers.indexOf(cleanLine);
                
                // Ki·ªÉm tra xem player n√†y c√≥ cell n√†o ƒë√£ tr√∫ng th∆∞·ªüng kh√¥ng
                let hasWon = false;
                if (playerIndex >= 0) {
                    for (let i = 0; i < cells.length; i++) {
                        if (cells[i].dataset.type === 'player' && 
                            parseInt(cells[i].dataset.playerIndex) === playerIndex &&
                            cells[i].dataset.won === 'true') {
                            hasWon = true;
                            break;
                        }
                    }
                }
                
                // Gi·ªØ nguy√™n s·ªë th·ª© t·ª±, th√™m d·∫•u sao n·∫øu ƒë√£ tr√∫ng
                const match = trimmed.match(/^(\d+)\.\s*(.*)$/);
                if (match) {
                    const num = match[1];
                    const content = match[2].replace(/‚≠ê\s*/, '').trim();
                    return hasWon ? `${num}. ‚≠ê ${content}` : `${num}. ${content}`;
                }
                return hasWon ? `‚≠ê ${trimmed}` : trimmed;
            });
            playersTextarea.value = updatedLines.join('\n');

            // C·∫≠p nh·∫≠t danh s√°ch ph·∫ßn th∆∞·ªüng
            const prizesTextarea = document.getElementById('prizesInput');
            prizesTextarea.value = prizes.map((p, i) => `${i + 1}. ${p}`).join('\n');
            
            saveGameData(); // L∆∞u d·ªØ li·ªáu sau khi c·∫≠p nh·∫≠t
        }

        // Th√™m v√†o l·ªãch s·ª≠
        let lastHistoryTurn = 0; // Track l∆∞·ª£t cu·ªëi c√πng ƒë√£ th√™m v√†o l·ªãch s·ª≠
        let currentHistoryItem = null; // L∆∞u history-item hi·ªán t·∫°i c·ªßa l∆∞·ª£t
        function addToHistory(message, incrementTurn = false) {
            if (incrementTurn) {
                turnCount++;
            }
            const historyContainer = document.getElementById('historyContainer');
            
            // N·∫øu ƒë√¢y l√† l∆∞·ª£t m·ªõi, t·∫°o history-item m·ªõi
            if (turnCount > 0 && turnCount !== lastHistoryTurn) {
                currentHistoryItem = document.createElement('div');
                currentHistoryItem.className = 'history-item';
                currentHistoryItem.innerHTML = `L∆∞·ª£t ${turnCount}: ${message}`;
                historyContainer.appendChild(currentHistoryItem);
                lastHistoryTurn = turnCount;
            } else if (currentHistoryItem && turnCount > 0) {
                // N·∫øu ƒë√£ c√≥ history-item c·ªßa l∆∞·ª£t n√†y, th√™m message v√†o (xu·ªëng d√≤ng)
                currentHistoryItem.innerHTML += `<br>${message}`;
            } else {
                // Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát (l∆∞·ª£t 0 ho·∫∑c ch∆∞a c√≥ l∆∞·ª£t)
                currentHistoryItem = document.createElement('div');
                currentHistoryItem.className = 'history-item';
                currentHistoryItem.innerHTML = message;
                historyContainer.appendChild(currentHistoryItem);
            }
            
            historyContainer.scrollTop = historyContainer.scrollHeight;
            gameHistory.push({ turn: turnCount, message: message });
            saveGameData(); // L∆∞u d·ªØ li·ªáu khi c√≥ l·ªãch s·ª≠ m·ªõi
        }

        // Hi·ªÉn th·ªã s·ª± ki·ªán
        function showEvent(message) {
            const eventDisplay = document.getElementById('eventDisplay');
            const eventText = document.getElementById('eventText');
            eventText.textContent = message;
            eventDisplay.classList.add('active');
            
            // Th√™m v√†o l·ªãch s·ª≠
            addToHistory(message);
            
            // T·ª± ƒë·ªông ·∫©n sau 5 gi√¢y
            setTimeout(() => {
                eventDisplay.classList.remove('active');
            }, 5000);
        }

        // H√†m highlight c√°c √¥ b·ªã ·∫£nh h∆∞·ªüng v√† th·ª±c hi·ªán h√†nh ƒë·ªông sau 2 gi√¢y
        function highlightAndExecute(affectedCellIndices, executeCallback, scrollToFirst = true) {
            // Th√™m class animation cho c√°c √¥ b·ªã ·∫£nh h∆∞·ªüng
            affectedCellIndices.forEach(cellIdx => {
                if (cells[cellIdx]) {
                    cells[cellIdx].classList.add('affected');
                    // Scroll ƒë·∫øn √¥ ƒë·∫ßu ti√™n n·∫øu c·∫ßn
                    if (scrollToFirst && cellIdx === affectedCellIndices[0]) {
                        cells[cellIdx].scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            });

            // Sau 2 gi√¢y, th·ª±c hi·ªán h√†nh ƒë·ªông v√† x√≥a animation
            setTimeout(() => {
                // Th·ª±c hi·ªán callback
                if (executeCallback) {
                    executeCallback();
                }

                // X√≥a class animation sau khi ho√†n th√†nh
                affectedCellIndices.forEach(cellIdx => {
                    if (cells[cellIdx]) {
                        cells[cellIdx].classList.remove('affected');
                    }
                });
            }, 2000);
        }

        // X·ª≠ l√Ω event cells
        function handleEvent(position) {
            const eventType = cells[position].dataset.eventType;
            const eventInfo = eventData[position];
            const diceBtn = document.getElementById('diceBtn');
            let message = '';

            switch (eventType) {
                // === DI CHUY·ªÇN ===
                case 'move_forward':
                    const forwardSteps = Math.floor(Math.random() * 5) + 1;
                    message = `‚û°Ô∏è Ti·∫øn th√™m ${forwardSteps} √¥`;
                    showEvent(message);
                    setTimeout(() => {
                        isMoving = true;
                        movePiece(forwardSteps);
                    }, 1500);
                    return;

                case 'move_backward':
                    // ƒê√°nh d·∫•u s·∫Ω l√πi ·ªü l·∫ßn gieo x√≠ ng·∫ßu ti·∫øp theo
                    shouldMoveBackward = true;
                    message = `‚¨ÖÔ∏è ${eventInfo.desc} - S·∫Ω l√πi ·ªü l·∫ßn gieo x√≠ ng·∫ßu ti·∫øp theo!`;
                    showEvent(message);
                    setTimeout(() => {
                        isMoving = false;
                        diceBtn.disabled = false;
                    }, 1500);
                    return;

                case 'jump_row':
                    // Nh·∫£y xu·ªëng h√†ng d·ªçc (GRID_COLS √¥) - xu·ªëng h√†ng d∆∞·ªõi
                    message = `‚¨áÔ∏è ${eventInfo.desc}`;
                    showEvent(message);
                    setTimeout(() => {
                        isMoving = true;
                        movePiece(GRID_COLS);
                    }, 1500);
                    return;

                case 'jump_row_up':
                    // Nh·∫£y l√™n h√†ng d·ªçc (-GRID_COLS √¥) - l√™n h√†ng tr√™n
                    message = `‚¨ÜÔ∏è ${eventInfo.desc}`;
                    showEvent(message);
                    setTimeout(() => {
                        isMoving = true;
                        movePiece(-GRID_COLS);
                    }, 1500);
                    return;

                case 'kill_on_path':
                    // ƒê√°nh d·∫•u s·∫Ω ti√™u di·ªát ng∆∞·ªùi ch∆°i khi ƒëi qua trong l∆∞·ª£t ti·∫øp theo
                    shouldKillOnPath = true;
                    message = `üíÄ ${eventInfo.desc}`;
                    showEvent(message);
                    playSound('event');
                    setTimeout(() => {
                        isMoving = false;
                        diceBtn.disabled = false;
                    }, 1500);
                    return;


                case 'bouncing_bomb':
                    // Bom n·∫£y - n·ªï x l·∫ßn m·ªói 2 ho·∫∑c 3 √¥
                    const bombTimes = Math.floor(Math.random() * 3) + 2; // 2-4 l·∫ßn
                    const bombInterval = Math.random() < 0.5 ? 2 : 3; // 2 ho·∫∑c 3 √¥
                    message = `üí£üí• Bom n·∫£y - n·ªï ${bombTimes} l·∫ßn m·ªói ${bombInterval} √¥!`;
                    showEvent(message);
                    playSound('event');
                    
                    // T√¨m c√°c √¥ b·ªã ·∫£nh h∆∞·ªüng
                    const startPos = position;
                    const affectedBombCells = [];
                    const affectedBombPlayers = [];
                    
                    for (let i = 0; i < bombTimes; i++) {
                        const bombPos = normalizePosition(startPos + (i + 1) * bombInterval);
                        if (cells[bombPos] && cells[bombPos].dataset.type === 'player' && !cells[bombPos].classList.contains('dead')) {
                            const pIdx = parseInt(cells[bombPos].dataset.playerIndex);
                            const cellKey = cells[bombPos].dataset.cellKey;
                            if (!playerWinners.has(pIdx) && !deadPlayers.has(cellKey) && !deadPlayers.has(pIdx)) {
                                affectedBombCells.push(bombPos);
                                affectedBombPlayers.push({ playerIndex: pIdx, cellIndex: bombPos });
                            }
                        }
                    }
                    
                    if (affectedBombCells.length > 0) {
                        highlightAndExecute(affectedBombCells, () => {
                            let killed = false;
                            const affectedCellNumbers = [];
                            
                            affectedBombPlayers.forEach(({ playerIndex, cellIndex }) => {
                                if (killPlayer(playerIndex, cellIndex)) {
                                    killed = true;
                                    affectedCellNumbers.push(cellIndex + 1);
                                }
                            });
                            
                            if (killed && affectedCellNumbers.length > 0) {
                                const historyMessage = `üí£üí• Bom n·∫£y - n·ªï ${bombTimes} l·∫ßn m·ªói ${bombInterval} √¥ (c√°c √¥ ${affectedCellNumbers.join(', ')})`;
                                addToHistory(historyMessage, false);
                            } else {
                                // N·∫øu kh√¥ng tr√∫ng, th√™m v√†o l·ªãch s·ª≠
                                addToHistory('üí£üí• Bom n·∫£y kh√¥ng tr√∫ng ng∆∞·ªùi ch∆°i n√†o!', false);
                            }
                            
                            checkAndRevivePlayers();
                            isMoving = false;
                            diceBtn.disabled = false;
                        });
                    } else {
                        setTimeout(() => {
                            showEvent('üí£üí• Bom n·∫£y kh√¥ng tr√∫ng ng∆∞·ªùi ch∆°i n√†o!');
                            addToHistory('üí£üí• Bom n·∫£y kh√¥ng tr√∫ng ng∆∞·ªùi ch∆°i n√†o!', false);
                            isMoving = false;
                            diceBtn.disabled = false;
                        }, 1500);
                    }
                    return;

                case 'portal':
                    // Portal - ƒëi t·∫Øt sang portal ng·∫´u nhi√™n (tr√°nh l·∫∑p l·∫°i)
                    if (hasTeleported) {
                        // ƒê√£ teleport r·ªìi, kh√¥ng teleport n·ªØa
                        message = `üåÄ ${eventInfo.desc}`;
                        showEvent(message);
                        playSound('event');
                        isMoving = false;
                        diceBtn.disabled = false;
                        return;
                    }
                    
                    message = `üåÄ ${eventInfo.desc}`;
                    showEvent(message);
                    playSound('event');
                    setTimeout(() => {
                        // Ch·ªçn ng·∫´u nhi√™n 1 portal kh√°c (kh√¥ng ph·∫£i portal hi·ªán t·∫°i)
                        const otherPortals = portalList.filter(p => p !== position);
                        if (otherPortals.length > 0) {
                            const randomPortal = otherPortals[Math.floor(Math.random() * otherPortals.length)];
                            hasTeleported = true; // ƒê√°nh d·∫•u ƒë√£ teleport
                            
                            cells[currentPosition].classList.remove('current');
                            currentPosition = randomPortal;
                            if (gamePiece && gamePiece.parentNode) {
                                gamePiece.parentNode.removeChild(gamePiece);
                            }
                            cells[currentPosition].appendChild(gamePiece);
                            cells[currentPosition].classList.add('current');
                            cells[currentPosition].scrollIntoView({ behavior: 'smooth', block: 'center' });
                            showEvent(`üåÄ ƒê√£ d·ªãch chuy·ªÉn ƒë·∫øn √¥ ${randomPortal + 1}!`);
                            
                            // Ki·ªÉm tra √¥ ƒë√≠ch, n·∫øu kh√¥ng ph·∫£i portal th√¨ m·ªõi x·ª≠ l√Ω landing
                            setTimeout(() => {
                                const targetCellType = cells[currentPosition].dataset.eventType;
                                if (targetCellType !== 'portal') {
                                    // Reset flag v√† x·ª≠ l√Ω landing b√¨nh th∆∞·ªùng
                                    hasTeleported = false;
                                    handleCellLanding(currentPosition);
                                } else {
                                    // N·∫øu √¥ ƒë√≠ch c≈©ng l√† portal, ch·ªâ reset flag v√† k·∫øt th√∫c l∆∞·ª£t
                                    hasTeleported = false;
                                    isMoving = false;
                                    diceBtn.disabled = false;
                                }
                            }, 1000);
                        } else {
                            hasTeleported = false;
                            isMoving = false;
                            diceBtn.disabled = false;
                        }
                    }, 1500);
                    return;

                // === T·∫§N C√îNG ===
                case 'kill_random':
                    message = `‚öîÔ∏è ${eventInfo.desc}`;
                    showEvent(message);
                    playSound('event');
                    
                    // T√¨m c√°c √¥ b·ªã ·∫£nh h∆∞·ªüng
                    const aliveCells = [];
                    for (let i = 0; i < cells.length; i++) {
                        if (cells[i].dataset.type === 'player' && !cells[i].classList.contains('dead')) {
                            const pIdx = parseInt(cells[i].dataset.playerIndex);
                            const cellKey = cells[i].dataset.cellKey;
                            if (!deadPlayers.has(cellKey) && !deadPlayers.has(pIdx) && !playerWinners.has(pIdx)) {
                                aliveCells.push({ cellIndex: i, playerIndex: pIdx });
                            }
                        }
                    }
                    
                    if (aliveCells.length > 0) {
                        // Ch·ªçn x ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n (x t·ª´ 1-5)
                        const killCount = Math.min(Math.floor(Math.random() * 5) + 1, aliveCells.length);
                        const shuffled = [...aliveCells].sort(() => Math.random() - 0.5);
                        const selected = shuffled.slice(0, killCount);
                        
                        const affectedCellIndices = selected.map(({ cellIndex }) => cellIndex);
                        
                        highlightAndExecute(affectedCellIndices, () => {
                            selected.forEach(({ playerIndex, cellIndex }) => {
                                killPlayer(playerIndex, cellIndex);
                            });
                            
                            if (selected.length > 0) {
                                addToHistory(`‚öîÔ∏è ƒê√£ ti√™u di·ªát ${selected.length} ng∆∞·ªùi ch∆°i ng·∫´u nhi√™n!`, false);
                            }
                            
                            checkAndRevivePlayers();
                            isMoving = false;
                            diceBtn.disabled = false;
                        });
                    } else {
                        setTimeout(() => {
                            isMoving = false;
                            diceBtn.disabled = false;
                        }, 1500);
                    }
                    return;

                case 'kill_nearest':
                    message = `‚öîÔ∏è ${eventInfo.desc}`;
                    showEvent(message);
                    playSound('event');
                    
                    // T√¨m t·∫•t c·∫£ ng∆∞·ªùi ch∆°i c√≤n s·ªëng v√† t√≠nh kho·∫£ng c√°ch
                    const playersWithDistance = [];
                    for (let i = 0; i < cells.length; i++) {
                        if (cells[i].dataset.type === 'player' && !cells[i].classList.contains('dead')) {
                            const pIdx = parseInt(cells[i].dataset.playerIndex);
                            const cellKey = cells[i].dataset.cellKey;
                            if (!deadPlayers.has(cellKey) && !deadPlayers.has(pIdx) && !playerWinners.has(pIdx)) {
                                // T√≠nh kho·∫£ng c√°ch (c·∫£ ph√≠a tr∆∞·ªõc v√† sau, ∆∞u ti√™n kho·∫£ng c√°ch ng·∫Øn nh·∫•t)
                                const forwardDist = i > position ? (i - position) : (i + TOTAL_CELLS - position);
                                const backwardDist = i < position ? (position - i) : (position + TOTAL_CELLS - i);
                                const distance = Math.min(forwardDist, backwardDist);
                                if (distance > 0) {
                                    playersWithDistance.push({ cellIndex: i, playerIndex: pIdx, distance: distance });
                                }
                            }
                        }
                    }
                    
                    if (playersWithDistance.length > 0) {
                        // S·∫Øp x·∫øp theo kho·∫£ng c√°ch (g·∫ßn nh·∫•t tr∆∞·ªõc)
                        playersWithDistance.sort((a, b) => a.distance - b.distance);
                        
                        // Ch·ªçn x ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t (x t·ª´ 1-5)
                        const killCount = Math.min(Math.floor(Math.random() * 5) + 1, playersWithDistance.length);
                        const selected = playersWithDistance.slice(0, killCount);
                        
                        const affectedCellIndices = selected.map(({ cellIndex }) => cellIndex);
                        
                        highlightAndExecute(affectedCellIndices, () => {
                            selected.forEach(({ playerIndex, cellIndex }) => {
                                killPlayer(playerIndex, cellIndex);
                            });
                            
                            if (selected.length > 0) {
                                addToHistory(`‚öîÔ∏è ƒê√£ ti√™u di·ªát ${selected.length} ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t!`, false);
                            }
                            
                            checkAndRevivePlayers();
                            isMoving = false;
                            diceBtn.disabled = false;
                        });
                    } else {
                        setTimeout(() => {
                            isMoving = false;
                            diceBtn.disabled = false;
                        }, 1500);
                    }
                    return;

                case 'bomb_row':
                    message = `üí£ ${eventInfo.desc}`;
                    showEvent(message);
                    playSound('event');
                    
                    const row = Math.floor(position / GRID_COLS);
                    const rowStart = row * GRID_COLS;
                    const rowEnd = Math.min(rowStart + GRID_COLS, TOTAL_CELLS);
                    const affectedRowCells = [];
                    const affectedRowPlayers = [];
                    
                    for (let i = rowStart; i < rowEnd; i++) {
                        if (cells[i] && cells[i].dataset.type === 'player' && !cells[i].classList.contains('dead')) {
                            const pIdx = parseInt(cells[i].dataset.playerIndex);
                            if (!playerWinners.has(pIdx)) {
                                affectedRowCells.push(i);
                                affectedRowPlayers.push({ playerIndex: pIdx, cellIndex: i });
                            }
                        }
                    }
                    
                    if (affectedRowCells.length > 0) {
                        highlightAndExecute(affectedRowCells, () => {
                            let killed = false;
                            affectedRowPlayers.forEach(({ playerIndex, cellIndex }) => {
                                if (killPlayer(playerIndex, cellIndex)) killed = true;
                            });
                            if (!killed) showEvent('üí£ Kh√¥ng c√≥ ng∆∞·ªùi ch∆°i n√†o trong h√†ng!');
                            checkAndRevivePlayers();
                            isMoving = false;
                            diceBtn.disabled = false;
                        });
                    } else {
                        setTimeout(() => {
                            showEvent('üí£ Kh√¥ng c√≥ ng∆∞·ªùi ch∆°i n√†o trong h√†ng!');
                            isMoving = false;
                            diceBtn.disabled = false;
                        }, 1500);
                    }
                    return;

                case 'bomb_col':
                    message = `üí£ ${eventInfo.desc}`;
                    showEvent(message);
                    playSound('event');
                    
                    const col = position % GRID_COLS;
                    const affectedColCells = [];
                    const affectedColPlayers = [];
                    
                    for (let i = col; i < TOTAL_CELLS; i += GRID_COLS) {
                        if (cells[i] && cells[i].dataset.type === 'player' && !cells[i].classList.contains('dead')) {
                            const pIdx = parseInt(cells[i].dataset.playerIndex);
                            if (!playerWinners.has(pIdx)) {
                                affectedColCells.push(i);
                                affectedColPlayers.push({ playerIndex: pIdx, cellIndex: i });
                            }
                        }
                    }
                    
                    if (affectedColCells.length > 0) {
                        highlightAndExecute(affectedColCells, () => {
                            let killed = false;
                            affectedColPlayers.forEach(({ playerIndex, cellIndex }) => {
                                if (killPlayer(playerIndex, cellIndex)) killed = true;
                            });
                            if (!killed) showEvent('üí£ Kh√¥ng c√≥ ng∆∞·ªùi ch∆°i n√†o trong c·ªôt!');
                            checkAndRevivePlayers();
                            isMoving = false;
                            diceBtn.disabled = false;
                        });
                    } else {
                        setTimeout(() => {
                            showEvent('üí£ Kh√¥ng c√≥ ng∆∞·ªùi ch∆°i n√†o trong c·ªôt!');
                            isMoving = false;
                            diceBtn.disabled = false;
                        }, 1500);
                    }
                    return;

                case 'bomb_cross':
                    message = `üí• ${eventInfo.desc}`;
                    showEvent(message);
                    playSound('event');
                    
                    const crossRow = Math.floor(position / GRID_COLS);
                    const crossCol = position % GRID_COLS;
                    const affectedCrossCells = [];
                    const affectedCrossPlayers = [];
                    
                    // Bom h√†ng ngang
                    const crossRowStart = crossRow * GRID_COLS;
                    const crossRowEnd = Math.min(crossRowStart + GRID_COLS, TOTAL_CELLS);
                    for (let i = crossRowStart; i < crossRowEnd; i++) {
                        if (cells[i] && cells[i].dataset.type === 'player' && !cells[i].classList.contains('dead')) {
                            const pIdx = parseInt(cells[i].dataset.playerIndex);
                            if (!playerWinners.has(pIdx) && !affectedCrossCells.includes(i)) {
                                affectedCrossCells.push(i);
                                affectedCrossPlayers.push({ playerIndex: pIdx, cellIndex: i });
                            }
                        }
                    }
                    
                    // Bom h√†ng d·ªçc
                    for (let i = crossCol; i < TOTAL_CELLS; i += GRID_COLS) {
                        if (cells[i] && cells[i].dataset.type === 'player' && !cells[i].classList.contains('dead')) {
                            const pIdx = parseInt(cells[i].dataset.playerIndex);
                            if (!playerWinners.has(pIdx) && !affectedCrossCells.includes(i)) {
                                affectedCrossCells.push(i);
                                affectedCrossPlayers.push({ playerIndex: pIdx, cellIndex: i });
                            }
                        }
                    }
                    
                    if (affectedCrossCells.length > 0) {
                        highlightAndExecute(affectedCrossCells, () => {
                            let killed = false;
                            affectedCrossPlayers.forEach(({ playerIndex, cellIndex }) => {
                                if (killPlayer(playerIndex, cellIndex)) killed = true;
                            });
                            if (!killed) showEvent('üí• Kh√¥ng c√≥ ng∆∞·ªùi ch∆°i n√†o b·ªã ·∫£nh h∆∞·ªüng!');
                            checkAndRevivePlayers();
                            isMoving = false;
                            diceBtn.disabled = false;
                        });
                    } else {
                        setTimeout(() => {
                            showEvent('üí• Kh√¥ng c√≥ ng∆∞·ªùi ch∆°i n√†o b·ªã ·∫£nh h∆∞·ªüng!');
                            isMoving = false;
                            diceBtn.disabled = false;
                        }, 1500);
                    }
                    return;

                // === T·∫§N C√îNG - THANH T·∫®Y ===
                case 'cleanse':
                    playSound('event');
                    
                    // Ch·ªçn ng·∫´u nhi√™n x √¥ (x t·ª´ 3 ƒë·∫øn 10) ƒë·ªÉ l√†m tr·ªëng
                    const cleanseCount = Math.floor(Math.random() * 8) + 3; // 3-10 √¥
                    
                    // T√¨m t·∫•t c·∫£ c√°c √¥ c√≥ th·ªÉ thanh t·∫©y (kh√¥ng ph·∫£i √¥ 0, kh√¥ng ph·∫£i √¥ ƒë√£ tr√∫ng th∆∞·ªüng)
                    const eligibleCells = [];
                    for (let i = 1; i < TOTAL_CELLS; i++) {
                        if (cells[i].dataset.won !== 'true') {
                            eligibleCells.push(i);
                        }
                    }
                    
                    // Ch·ªçn ng·∫´u nhi√™n x √¥
                    const shuffled = [...eligibleCells].sort(() => Math.random() - 0.5);
                    const cellsToCleanse = shuffled.slice(0, Math.min(cleanseCount, eligibleCells.length));
                    
                    if (cellsToCleanse.length > 0) {
                        highlightAndExecute(cellsToCleanse, () => {
                            const cleansedCells = [];
                            cellsToCleanse.forEach(cellIdx => {
                                const cell = cells[cellIdx];
                                const cellType = cell.dataset.type;
                                
                                // L√†m tr·ªëng √¥ (x√≥a player ho·∫∑c event)
                                if (cellType === 'player') {
                                    // X√≥a player kh·ªèi cell
                                    const playerIdx = parseInt(cell.dataset.playerIndex);
                                    const cellKey = cell.dataset.cellKey;
                                    
                                    // X√≥a kh·ªèi playerCellMap
                                    playerCellMap.delete(cellIdx);
                                    
                                    // X√≥a kh·ªèi deadPlayers n·∫øu c√≥
                                    deadPlayers.delete(cellKey);
                                    
                                    // X√≥a kh·ªèi eventCells n·∫øu c√≥
                                    const eventIndex = eventCells.indexOf(cellIdx);
                                    if (eventIndex > -1) {
                                        eventCells.splice(eventIndex, 1);
                                        delete eventData[cellIdx];
                                    }
                                    
                                    cleansedCells.push(cellIdx + 1);
                                } else if (cellType === 'event') {
                                    // X√≥a event kh·ªèi cell
                                    const eventIndex = eventCells.indexOf(cellIdx);
                                    if (eventIndex > -1) {
                                        eventCells.splice(eventIndex, 1);
                                        delete eventData[cellIdx];
                                    }
                                    
                                    // X√≥a kh·ªèi portalList n·∫øu c√≥
                                    const portalIndex = portalList.indexOf(cellIdx);
                                    if (portalIndex > -1) {
                                        portalList.splice(portalIndex, 1);
                                    }
                                    
                                    cleansedCells.push(cellIdx + 1);
                                }
                                
                                // Reset cell v·ªÅ tr·∫°ng th√°i tr·ªëng
                                cell.className = 'cell';
                                cell.textContent = '';
                                cell.dataset.type = '';
                                cell.dataset.eventType = '';
                                cell.dataset.tooltip = '';
                                cell.title = '';
                                cell.dataset.playerIndex = '';
                                cell.dataset.cellKey = '';
                                cell.classList.remove('player', 'dead', 'winner', 'event', 'movement', 'attack', 'defense', 'affected');
                                // Gi·ªØ l·∫°i data-cell-number
                                if (!cell.dataset.cellNumber) {
                                    cell.dataset.cellNumber = cellIdx + 1;
                                }
                            });
                            
                            if (cleansedCells.length > 0) {
                                const cleanseMessage = `‚ú® Thanh t·∫©y - L√†m tr·ªëng ng·∫´u nhi√™n ${cleansedCells.length} √¥`;
                                showEvent(cleanseMessage);
                                addToHistory(cleanseMessage, false);
                            } else {
                                const cleanseMessage = '‚ú® Thanh t·∫©y - Kh√¥ng c√≥ √¥ n√†o ƒë·ªÉ thanh t·∫©y!';
                                showEvent(cleanseMessage);
                                addToHistory(cleanseMessage, false);
                            }
                            
                            saveGameData();
                            isMoving = false;
                            diceBtn.disabled = false;
                        });
                    } else {
                        setTimeout(() => {
                            const cleanseMessage = '‚ú® Thanh t·∫©y - Kh√¥ng c√≥ √¥ n√†o ƒë·ªÉ thanh t·∫©y!';
                            showEvent(cleanseMessage);
                            addToHistory(cleanseMessage, false);
                            isMoving = false;
                            diceBtn.disabled = false;
                        }, 1500);
                    }
                    return;
            }
            
            // === THANH T·∫®Y KHI ƒê·∫¶Y ===
            if (eventType === 'full_cleanse') {
                playSound('event');
                
                // Ch·ªçn ng·∫´u nhi√™n 10 √¥ ƒë·ªÉ l√†m tr·ªëng
                const fullCleanseCount = 10;
                
                // T√¨m t·∫•t c·∫£ c√°c √¥ c√≥ th·ªÉ thanh t·∫©y (kh√¥ng ph·∫£i √¥ 0, kh√¥ng ph·∫£i √¥ ƒë√£ tr√∫ng th∆∞·ªüng)
                const fullEligibleCells = [];
                for (let i = 1; i < TOTAL_CELLS; i++) {
                    if (cells[i].dataset.won !== 'true') {
                        fullEligibleCells.push(i);
                    }
                }
                
                // Ch·ªçn ng·∫´u nhi√™n 10 √¥
                const fullShuffled = [...fullEligibleCells].sort(() => Math.random() - 0.5);
                const fullCellsToCleanse = fullShuffled.slice(0, Math.min(fullCleanseCount, fullEligibleCells.length));
                
                if (fullCellsToCleanse.length > 0) {
                    highlightAndExecute(fullCellsToCleanse, () => {
                        const fullCleansedCells = [];
                        fullCellsToCleanse.forEach(cellIdx => {
                            const cell = cells[cellIdx];
                            const cellType = cell.dataset.type;
                            
                            // L√†m tr·ªëng √¥ (x√≥a player ho·∫∑c event)
                            if (cellType === 'player') {
                                // X√≥a player kh·ªèi cell
                                const playerIdx = parseInt(cell.dataset.playerIndex);
                                const cellKey = cell.dataset.cellKey;
                                
                                // X√≥a kh·ªèi playerCellMap
                                playerCellMap.delete(cellIdx);
                                
                                // X√≥a kh·ªèi deadPlayers n·∫øu c√≥
                                deadPlayers.delete(cellKey);
                                
                                // X√≥a kh·ªèi eventCells n·∫øu c√≥
                                const eventIndex = eventCells.indexOf(cellIdx);
                                if (eventIndex > -1) {
                                    eventCells.splice(eventIndex, 1);
                                    delete eventData[cellIdx];
                                }
                                
                                fullCleansedCells.push(cellIdx + 1);
                            } else if (cellType === 'event') {
                                // X√≥a event kh·ªèi cell
                                const eventIndex = eventCells.indexOf(cellIdx);
                                if (eventIndex > -1) {
                                    eventCells.splice(eventIndex, 1);
                                    delete eventData[cellIdx];
                                }
                                
                                // X√≥a kh·ªèi portalList n·∫øu c√≥
                                const portalIndex = portalList.indexOf(cellIdx);
                                if (portalIndex > -1) {
                                    portalList.splice(portalIndex, 1);
                                }
                                
                                fullCleansedCells.push(cellIdx + 1);
                            }
                            
                            // Reset cell v·ªÅ tr·∫°ng th√°i tr·ªëng
                            cell.className = 'cell';
                            cell.textContent = '';
                            cell.dataset.type = '';
                            cell.dataset.eventType = '';
                            cell.dataset.tooltip = '';
                            cell.title = '';
                            cell.dataset.playerIndex = '';
                            cell.dataset.cellKey = '';
                            cell.classList.remove('player', 'dead', 'winner', 'event', 'movement', 'attack', 'defense', 'affected');
                            // Gi·ªØ l·∫°i data-cell-number
                            if (!cell.dataset.cellNumber) {
                                cell.dataset.cellNumber = cellIdx + 1;
                            }
                        });
                        
                        if (fullCleansedCells.length > 0) {
                            const fullCleanseMessage = `‚ú® Thanh t·∫©y khi ƒë·∫ßy - L√†m tr·ªëng ng·∫´u nhi√™n ${fullCleansedCells.length} √¥`;
                            showEvent(fullCleanseMessage);
                            addToHistory(fullCleanseMessage, false);
                        } else {
                            const fullCleanseMessage = '‚ú® Thanh t·∫©y khi ƒë·∫ßy - Kh√¥ng c√≥ √¥ n√†o ƒë·ªÉ thanh t·∫©y!';
                            showEvent(fullCleanseMessage);
                            addToHistory(fullCleanseMessage, false);
                        }
                        
                        saveGameData();
                        isMoving = false;
                        diceBtn.disabled = false;
                    });
                } else {
                    setTimeout(() => {
                        const fullCleanseMessage = '‚ú® Thanh t·∫©y khi ƒë·∫ßy - Kh√¥ng c√≥ √¥ n√†o ƒë·ªÉ thanh t·∫©y!';
                        showEvent(fullCleanseMessage);
                        addToHistory(fullCleanseMessage, false);
                        isMoving = false;
                        diceBtn.disabled = false;
                    }, 500);
                }
                return;
            }

            // M·∫∑c ƒë·ªãnh
            isMoving = false;
            diceBtn.disabled = false;
        }
        
        // H√†m th·ª±c hi·ªán thanh t·∫©y khi ƒë·∫ßy
        function performFullCleanse() {
            // T·∫°o m·ªôt √¥ t·∫°m th·ªùi ƒë·ªÉ trigger handleEvent
            const tempCellIndex = 0; // S·ª≠ d·ª•ng √¥ 0 l√†m trigger
            cells[tempCellIndex].dataset.eventType = 'full_cleanse';
            handleEvent(tempCellIndex);
            cells[tempCellIndex].dataset.eventType = '';
        }

        // Hi·ªÉn th·ªã th√¥ng b√°o ch√∫c m·ª´ng
        function showCongratulations(player, prize) {
            const congrats = document.getElementById('congratulations');
            document.getElementById('congratsPlayer').textContent = player;
            document.getElementById('congratsPrize').textContent = `Nh·∫≠n ƒë∆∞·ª£c: ${prize}`;
            
            // Hi·ªÉn th·ªã s·ªë ph·∫ßn th∆∞·ªüng c√≤n l·∫°i
            const remainingCount = prizes.length;
            const remainingDiv = document.getElementById('congratsRemaining');
            if (remainingCount > 0) {
                remainingDiv.innerHTML = `<p style="font-size: 18px; color: #ffd700; font-weight: bold;">üì¶ C√≤n l·∫°i: ${remainingCount} ph·∫ßn th∆∞·ªüng</p>`;
            } else {
                remainingDiv.innerHTML = `<p style="font-size: 18px; color: #ffd700; font-weight: bold;">üéâ ƒê√£ trao h·∫øt ph·∫ßn th∆∞·ªüng!</p>`;
            }
            
            // Hi·ªÉn th·ªã danh s√°ch ph·∫ßn th∆∞·ªüng c√≤n l·∫°i
            const prizesListDiv = document.getElementById('congratsPrizesList');
            if (prizes.length > 0) {
                prizesListDiv.innerHTML = '<p style="font-size: 14px; color: rgba(255,255,255,0.9); margin-bottom: 8px; font-weight: bold;">üìã Danh s√°ch ph·∫ßn th∆∞·ªüng c√≤n l·∫°i:</p>' +
                    prizes.map((p, index) => `<div style="font-size: 13px; color: rgba(255,255,255,0.8); padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">${index + 1}. ${p}</div>`).join('');
            } else {
                prizesListDiv.innerHTML = '<p style="font-size: 14px; color: rgba(255,255,255,0.8);">Kh√¥ng c√≤n ph·∫ßn th∆∞·ªüng n√†o</p>';
            }
            
            congrats.classList.add('active');
            
            setTimeout(() => {
                congrats.classList.remove('active');
            }, 5000); // TƒÉng th·ªùi gian hi·ªÉn th·ªã l√™n 5 gi√¢y ƒë·ªÉ ng∆∞·ªùi d√πng c√≥ th·ªùi gian xem
        }

        // Th√™m k·∫øt qu·∫£ v√†o zone999
        function addResult(player, prize, playerIndex = -1) {
            // Hi·ªÉn th·ªã th√¥ng b√°o ch√∫c m·ª´ng
            showCongratulations(player, prize);

            // Th√™m v√†o zone999 (b√™n tr√°i)
            const resultsContainer = document.getElementById('resultsContainer');
            const resultItem = document.createElement('div');
            resultItem.className = 'result-item';
            resultItem.innerHTML = `
                <span><strong>${player}</strong></span>
                <span>${prize}</span>
            `;
            resultsContainer.appendChild(resultItem);
            resultsContainer.scrollTop = resultsContainer.scrollHeight;

            // Hi·ªÉn th·ªã n√∫t copy n·∫øu c√≥ k·∫øt qu·∫£
            const copyBtn = document.getElementById('copyResultsBtn');
            if (copyBtn) {
                copyBtn.style.display = 'block';
                // CƒÉn tr√°i ti√™u ƒë·ªÅ khi c√≥ n√∫t copy
                const zone999Header = document.querySelector('.zone999-header');
                const zone999H3 = zone999Header ? zone999Header.querySelector('h3') : null;
                if (zone999Header) {
                    zone999Header.style.justifyContent = 'flex-start';
                }
                if (zone999H3) {
                    zone999H3.style.textAlign = 'left';
                }
            }

            // Th√™m v√†o l·ªãch s·ª≠ v·ªõi th√¥ng tin ng∆∞·ªùi chi·∫øn th·∫Øng
            addToHistory(`üèÜ ${player} tr√∫ng th∆∞·ªüng: ${prize}`, false);
            saveGameData(); // L∆∞u d·ªØ li·ªáu khi c√≥ k·∫øt qu·∫£ m·ªõi
        }

        // H√†m ti√™u di·ªát ng∆∞·ªùi ch∆°i (ch·ªâ ·ªü cell c·ª• th·ªÉ)
        function killPlayer(playerIndex, cellIndex = -1) {
            if (playerIndex < 0 || playerIndex >= originalPlayers.length || playerWinners.has(playerIndex)) {
                return false;
            }

            // T√¨m cell c·ª• th·ªÉ n·∫øu c√≥
            let targetCell = null;
            let cellKey = null;
            
            if (cellIndex >= 0 && cells[cellIndex] && cells[cellIndex].dataset.type === 'player' && 
                parseInt(cells[cellIndex].dataset.playerIndex) === playerIndex) {
                targetCell = cells[cellIndex];
                cellKey = targetCell.dataset.cellKey || `${cellIndex}_${playerIndex}`;
            } else {
                // T√¨m cell ƒë·∫ßu ti√™n c√≥ player n√†y
                for (let i = 0; i < cells.length; i++) {
                    if (cells[i].dataset.type === 'player' && parseInt(cells[i].dataset.playerIndex) === playerIndex) {
                        targetCell = cells[i];
                        cellKey = targetCell.dataset.cellKey || `${i}_${playerIndex}`;
                        cellIndex = i;
                        break;
                    }
                }
            }

            if (!targetCell) return false;

            // Ki·ªÉm tra xem cell n√†y ƒë√£ ch·∫øt ch∆∞a
            if (deadPlayers.has(cellKey) || deadPlayers.has(playerIndex)) {
                return false;
            }


            // ƒê√°nh d·∫•u cell n√†y l√† dead (kh√¥ng ·∫£nh h∆∞·ªüng c√°c cell kh√°c)
            deadPlayers.add(cellKey);
            // Hi·ªÉn th·ªã s·ªë √¥ ƒë√∫ng (cellIndex + 1 v√¨ ƒë·∫øm t·ª´ 1)
            const cellNumber = cellIndex + 1;
            showEvent(`üíÄ ${originalPlayers[playerIndex]} ƒë√£ b·ªã ti√™u di·ªát ·ªü √¥ ${cellNumber}!`);
            playSound('kill');
            
            // C·∫≠p nh·∫≠t grid - ƒë√°nh d·∫•u √¥ l√† dead (gi·ªØ nguy√™n t√™n)
            targetCell.classList.add('dead');
            targetCell.style.background = '#3c3c3c';
            targetCell.style.color = '#ecf0f1';
            targetCell.style.border = '2px solid #2c2c2c';
            
            return true;
        }

        // H√†m l·∫•y v·ªã tr√≠ t·ª´ cell index
        function getCellPositionFromIndex(cellIndex) {
            const row = Math.floor(cellIndex / GRID_COLS);
            const col = cellIndex % GRID_COLS;
            return `${row}${col}`;
        }

        // H√†m l·∫•y v·ªã tr√≠ √¥ c·ªßa player (cell ƒë·∫ßu ti√™n t√¨m th·∫•y)
        function getCellPosition(playerIndex) {
            for (let i = 0; i < cells.length; i++) {
                if (cells[i].dataset.type === 'player' && parseInt(cells[i].dataset.playerIndex) === playerIndex) {
                    return getCellPositionFromIndex(i);
                }
            }
            return '?';
        }

        // H√†m t√¨m ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t
        function findNearestPlayer(position, direction = 'forward') {
            let nearestPlayer = -1;
            let minDistance = TOTAL_CELLS;
            
            for (let i = 0; i < cells.length; i++) {
                if (cells[i] && cells[i].dataset.type === 'player' && !cells[i].classList.contains('dead')) {
                    const pIdx = parseInt(cells[i].dataset.playerIndex);
                    const cellKey = cells[i].dataset.cellKey;
                    if (!deadPlayers.has(cellKey) && !deadPlayers.has(pIdx) && !playerWinners.has(pIdx)) {
                        let distance;
                        if (direction === 'forward') {
                            distance = i > position ? (i - position) : (i + TOTAL_CELLS - position);
                        } else {
                            distance = i < position ? (position - i) : (position + TOTAL_CELLS - i);
                        }
                        if (distance > 0 && distance < minDistance) {
                            minDistance = distance;
                            nearestPlayer = i;
                        }
                    }
                }
            }
            
            return nearestPlayer;
        }

        // L∆∞u d·ªØ li·ªáu v√†o localStorage
        function saveGameData() {
            if (isLoadingData) return; // Kh√¥ng l∆∞u khi ƒëang load
            try {
                // L∆∞u th√¥ng tin c√°c √¥ ƒë√£ tr√∫ng th∆∞·ªüng
                const wonCells = [];
                cells.forEach((cell, idx) => {
                    if (cell.dataset.won === 'true') {
                        wonCells.push({
                            index: idx,
                            playerIndex: parseInt(cell.dataset.playerIndex) || -1
                        });
                    }
                });
                
                const gameData = {
                    playersInput: document.getElementById('playersInput').value,
                    prizesInput: document.getElementById('prizesInput').value,
                    gameStarted: gameStarted,
                    currentPosition: currentPosition,
                    originalPlayers: originalPlayers,
                    originalPrizes: originalPrizes,
                    players: players,
                    prizes: prizes,
                    deadPlayers: Array.from(deadPlayers),
                    playerWinners: Array.from(playerWinners),
                    playerShields: playerShields,
                    turnCount: turnCount,
                    roundCount: roundCount,
                    playerRepeatMultiplier: playerRepeatMultiplier,
                    eventMultiplier: eventMultiplier,
                lastWinTurn: lastWinTurn,
                gameHistory: gameHistory,
                resultsHTML: document.getElementById('resultsContainer').innerHTML,
                historyHTML: document.getElementById('historyContainer').innerHTML,
                avatarImage: avatarImage,
                shouldMoveBackward: shouldMoveBackward,
                shouldKillOnPath: shouldKillOnPath,
                eventCells: eventCells,
                eventData: eventData,
                portalList: portalList,
                wonCells: wonCells,
                hasPerformedFullCleanse: hasPerformedFullCleanse
            };
                localStorage.setItem('giveAwayGameData', JSON.stringify(gameData));
            } catch (e) {
                console.error('L·ªói khi l∆∞u d·ªØ li·ªáu:', e);
            }
        }

        // Load d·ªØ li·ªáu t·ª´ localStorage
        function loadGameData() {
            isLoadingData = true; // ƒê√°nh d·∫•u ƒëang load
            const savedData = localStorage.getItem('giveAwayGameData');
            if (savedData) {
                try {
                    const gameData = JSON.parse(savedData);
                    
                    // Kh√¥i ph·ª•c input
                    if (gameData.playersInput) {
                        document.getElementById('playersInput').value = gameData.playersInput;
                    }
                    if (gameData.prizesInput) {
                        document.getElementById('prizesInput').value = gameData.prizesInput;
                    }
                    
                    // Kh√¥i ph·ª•c tr·∫°ng th√°i game n·∫øu ƒëang ch∆°i
                    if (gameData.gameStarted) {
                        originalPlayers = gameData.originalPlayers || [];
                        originalPrizes = gameData.originalPrizes || [];
                        players = gameData.players || [];
                        prizes = gameData.prizes || [];
                        deadPlayers = new Set(gameData.deadPlayers || []);
                        playerWinners = new Set(gameData.playerWinners || []);
                        playerShields = gameData.playerShields || {};
                        turnCount = gameData.turnCount || 0;
                        roundCount = gameData.roundCount || 0;
                        playerRepeatMultiplier = gameData.playerRepeatMultiplier || 1;
                        eventMultiplier = gameData.eventMultiplier || 1;
                        lastWinTurn = gameData.lastWinTurn || 0;
                        gameHistory = gameData.gameHistory || [];
                        currentPosition = gameData.currentPosition || 0;
                        avatarImage = gameData.avatarImage || null;
                        shouldMoveBackward = gameData.shouldMoveBackward || false;
                        shouldKillOnPath = gameData.shouldKillOnPath || false;
                        hasPerformedFullCleanse = gameData.hasPerformedFullCleanse || false;
                        eventCells = gameData.eventCells || [];
                        eventData = gameData.eventData || {};
                        // H·ªó tr·ª£ c·∫£ portalPairs (c≈©) v√† portalList (m·ªõi) ƒë·ªÉ t∆∞∆°ng th√≠ch ng∆∞·ª£c
                        if (gameData.portalList) {
                            portalList = gameData.portalList;
                        } else if (gameData.portalPairs) {
                            // Chuy·ªÉn ƒë·ªïi t·ª´ portalPairs c≈© sang portalList
                            portalList = gameData.portalPairs;
                        } else {
                            portalList = [];
                        }
                        const wonCells = gameData.wonCells || [];
                        
                        // Kh√¥i ph·ª•c k·∫øt qu·∫£ v√† l·ªãch s·ª≠
                        if (gameData.resultsHTML) {
                            document.getElementById('resultsContainer').innerHTML = gameData.resultsHTML;
                            // Hi·ªÉn th·ªã n√∫t copy n·∫øu c√≥ k·∫øt qu·∫£
                            const resultsContainer = document.getElementById('resultsContainer');
                            const copyBtn = document.getElementById('copyResultsBtn');
                            if (copyBtn && resultsContainer.querySelectorAll('.result-item').length > 0) {
                                copyBtn.style.display = 'block';
                                // CƒÉn tr√°i ti√™u ƒë·ªÅ khi c√≥ n√∫t copy
                                const zone999Header = document.querySelector('.zone999-header');
                                const zone999H3 = zone999Header ? zone999Header.querySelector('h3') : null;
                                if (zone999Header) {
                                    zone999Header.style.justifyContent = 'flex-start';
                                }
                                if (zone999H3) {
                                    zone999H3.style.textAlign = 'left';
                                }
                            }
                        }
                        if (gameData.historyHTML) {
                            document.getElementById('historyContainer').innerHTML = gameData.historyHTML;
                            // Reset lastHistoryTurn v√† currentHistoryItem ƒë·ªÉ ƒë·∫£m b·∫£o hi·ªÉn th·ªã ƒë√∫ng khi th√™m s·ª± ki·ªán m·ªõi
                            lastHistoryTurn = turnCount;
                            // T√¨m history-item cu·ªëi c√πng c·ªßa l∆∞·ª£t hi·ªán t·∫°i
                            const historyContainer = document.getElementById('historyContainer');
                            const historyItems = historyContainer.querySelectorAll('.history-item');
                            if (historyItems.length > 0) {
                                const lastItem = historyItems[historyItems.length - 1];
                                if (lastItem.textContent.startsWith(`L∆∞·ª£t ${turnCount}:`)) {
                                    currentHistoryItem = lastItem;
                                } else {
                                    currentHistoryItem = null;
                                }
                            } else {
                                currentHistoryItem = null;
                            }
                        }
                        
                        // Kh√¥i ph·ª•c avatar n·∫øu c√≥
                        if (avatarImage) {
                            const preview = document.getElementById('avatarPreview');
                            if (preview) {
                                preview.src = avatarImage;
                                preview.style.display = 'block';
                            }
                        }
                        
                        // Kh·ªüi t·∫°o grid v√† kh√¥i ph·ª•c game
                        initGrid();
                        gameStarted = true;
                        
                        // Kh√¥i ph·ª•c event cells tr∆∞·ªõc khi ph√¢n b·ªï players
                        if (eventCells.length > 0) {
                            eventCells.forEach(idx => {
                                if (cells[idx] && eventData[idx]) {
                                    const eventInfo = eventData[idx];
                                    cells[idx].className = `cell event ${eventInfo.category}`;
                                    cells[idx].textContent = eventInfo.icon;
                                    cells[idx].dataset.type = 'event';
                                    cells[idx].dataset.eventType = eventInfo.type;
                                    cells[idx].dataset.tooltip = eventInfo.desc;
                                    cells[idx].title = eventInfo.desc;
                                    // ƒê·∫£m b·∫£o c√≥ data-cell-number ƒë·ªÉ hi·ªÉn th·ªã s·ªë th·ª© t·ª±
                                    cells[idx].dataset.cellNumber = idx + 1;
                                }
                            });
                        }
                        
                        // Kh√¥i ph·ª•c c√°c √¥ ƒë√£ tr√∫ng th∆∞·ªüng (n·∫øu c√≥)
                        wonCells.forEach(({ index, playerIndex }) => {
                            if (cells[index] && playerIndex >= 0 && originalPlayers[playerIndex]) {
                                cells[index].classList.add('player', 'winner');
                                cells[index].textContent = originalPlayers[playerIndex];
                                cells[index].dataset.type = 'player';
                                cells[index].dataset.playerIndex = playerIndex;
                                cells[index].dataset.won = 'true';
                                cells[index].dataset.cellKey = `${index}_${playerIndex}`;
                            }
                        });
                        
                        distributePlayers(false);
                        createGamePiece();
                        
                        // Kh√¥i ph·ª•c v·ªã tr√≠ qu√¢n c·ªù
                        if (cells[currentPosition] && gamePiece) {
                            cells[currentPosition].appendChild(gamePiece);
                            cells[currentPosition].classList.add('current');
                        }
                        
                        // Hi·ªÉn th·ªã n√∫t gieo x√∫c x·∫Øc v√† l√†m ch√¨m n√∫t b·∫Øt ƒë·∫ßu
                        const diceBtn = document.getElementById('diceBtn');
                        diceBtn.style.display = 'block';
                        if (gameStarted) {
                            // Enable n√∫t gieo x√∫c x·∫Øc n·∫øu game ƒë√£ b·∫Øt ƒë·∫ßu
                            diceBtn.disabled = false;
                            diceBtn.style.opacity = '1';
                            diceBtn.style.cursor = 'pointer';
                            diceBtn.style.transform = 'scale(1)';
                            
                            // L√†m ch√¨m n√∫t b·∫Øt ƒë·∫ßu
                            const startBtn = document.getElementById('startBtn');
                            startBtn.disabled = true;
                            startBtn.style.opacity = '0.3';
                            startBtn.style.cursor = 'not-allowed';
                            startBtn.style.transform = 'scale(0.95)';
                        } else {
                            // N·∫øu game ch∆∞a b·∫Øt ƒë·∫ßu, disable n√∫t gieo x√∫c x·∫Øc
                            diceBtn.disabled = true;
                            diceBtn.style.opacity = '0.3';
                            diceBtn.style.cursor = 'not-allowed';
                            diceBtn.style.transform = 'scale(0.95)';
                        }
                        
                        // C·∫≠p nh·∫≠t c√°c giai ƒëo·∫°n
                        updateStages();
                    }
                    
                    checkStartButton();
                    updateStages();
                } catch (e) {
                    console.error('L·ªói khi load d·ªØ li·ªáu:', e);
                }
            }
            isLoadingData = false; // Ho√†n t·∫•t load
        }

        // X√≥a t·∫•t c·∫£ d·ªØ li·ªáu
        function clearAllData() {
            if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a t·∫•t c·∫£ d·ªØ li·ªáu v√† b·∫Øt ƒë·∫ßu l·∫°i?')) {
                localStorage.removeItem('giveAwayGameData');
                
                // Reset bi·∫øn gameStarted TR∆Ø·ªöC ƒë·ªÉ ƒë·∫£m b·∫£o logic ƒë√∫ng
                gameStarted = false;
                
                // Reset t·∫•t c·∫£
                document.getElementById('playersInput').value = '';
                document.getElementById('prizesInput').value = '';
                document.getElementById('resultsContainer').innerHTML = '';
                document.getElementById('historyContainer').innerHTML = '';
                document.getElementById('avatarPreview').style.display = 'none';
                
                // Reset n√∫t Nh√¢n Ph·∫©m - hi·ªÉn th·ªã nh∆∞ng disabled (ch√¨m)
                const diceBtn = document.getElementById('diceBtn');
                diceBtn.style.display = 'block';
                diceBtn.disabled = true;
                diceBtn.style.opacity = '0.3';
                diceBtn.style.cursor = 'not-allowed';
                diceBtn.style.transform = 'scale(0.95)';
                
                // Reset n√∫t B·∫Øt ƒë·∫ßu - hi·ªÉn th·ªã v√† reset v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu
                const startBtn = document.getElementById('startBtn');
                startBtn.style.display = 'block';
                startBtn.disabled = true;
                startBtn.style.opacity = '0.5';
                startBtn.style.cursor = 'not-allowed';
                startBtn.style.transform = 'scale(1)';
                
                const copyBtn = document.getElementById('copyResultsBtn');
                if (copyBtn) {
                    copyBtn.style.display = 'none';
                    // CƒÉn gi·ªØa ti√™u ƒë·ªÅ khi kh√¥ng c√≥ n√∫t copy
                    const zone999Header = document.querySelector('.zone999-header');
                    const zone999H3 = zone999Header ? zone999Header.querySelector('h3') : null;
                    if (zone999Header) {
                        zone999Header.style.justifyContent = 'center';
                    }
                    if (zone999H3) {
                        zone999H3.style.textAlign = 'center';
                    }
                }
                
                originalPlayers = [];
                originalPrizes = [];
                players = [];
                prizes = [];
                deadPlayers = new Set();
                playerWinners = new Set();
                playerShields = {};
                gameHistory = [];
                turnCount = 0;
                lastHistoryTurn = 0;
                currentHistoryItem = null;
                roundCount = 0;
                hasPerformedFullCleanse = false;
                playerRepeatMultiplier = 1;
                eventMultiplier = 1;
                lastWinTurn = 0;
                currentPosition = 0;
                avatarImage = null;
                shouldMoveBackward = false;
                shouldKillOnPath = false;
                portalList = [];
                hasTeleported = false;
                eventCells = [];
                eventData = {};
                playerCellMap = new Map();
                isMoving = false;
                
                // X√≥a qu√¢n c·ªù n·∫øu c√≥
                if (gamePiece) {
                    gamePiece.remove();
                    gamePiece = null;
                }
                
                initGrid();
                checkStartButton(); // G·ªçi l·∫°i ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i (s·∫Ω disable v√¨ ch∆∞a c√≥ input)
            }
        }


        // N√∫t X√ìA T·∫§T C·∫¢
        document.getElementById('clearBtn').addEventListener('click', clearAllData);

        // N√∫t Copy k·∫øt qu·∫£
        document.getElementById('copyResultsBtn').addEventListener('click', function() {
            const resultsContainer = document.getElementById('resultsContainer');
            const resultItems = resultsContainer.querySelectorAll('.result-item');
            
            if (resultItems.length === 0) {
                alert('Ch∆∞a c√≥ k·∫øt qu·∫£ n√†o ƒë·ªÉ copy!');
                return;
            }
            
            // T·∫°o text ƒë·ªÉ copy
            let textToCopy = 'üèÜ K·∫æT QU·∫¢ TRAO TH∆Ø·ªûNG\n';
            textToCopy += '='.repeat(30) + '\n\n';
            
            resultItems.forEach((item, index) => {
                const spans = item.querySelectorAll('span');
                if (spans.length >= 2) {
                    const player = spans[0].textContent.trim();
                    const prize = spans[1].textContent.trim();
                    textToCopy += `${index + 1}. ${player} - ${prize}\n`;
                }
            });
            
            // Copy v√†o clipboard
            navigator.clipboard.writeText(textToCopy).then(() => {
                // Th√¥ng b√°o th√†nh c√¥ng
                const btn = document.getElementById('copyResultsBtn');
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ ƒê√£ copy!';
                btn.style.background = 'rgba(76, 175, 80, 0.3)';
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = 'rgba(255,255,255,0.2)';
                }, 2000);
            }).catch(err => {
                console.error('L·ªói khi copy:', err);
                alert('Kh√¥ng th·ªÉ copy k·∫øt qu·∫£. Vui l√≤ng th·ª≠ l·∫°i!');
            });
        });

        // L∆∞u d·ªØ li·ªáu ƒë·ªãnh k·ª≥ v√† khi c√≥ s·ª± ki·ªán
        setInterval(saveGameData, 5000); // L∆∞u m·ªói 5 gi√¢y

        // C·∫≠p nh·∫≠t tr·∫°ng th√°i c√°c giai ƒëo·∫°n
        function updateStages() {
            const stage1 = document.getElementById('stage1');
            const stage2 = document.getElementById('stage2');
            const stage3 = document.getElementById('stage3');
            const stageLucky = document.getElementById('stageLucky');
            const stageFull = document.getElementById('stageFull');
            const stage1Title = document.getElementById('stage1Title');
            const stage2Title = document.getElementById('stage2Title');
            const stage3Title = document.getElementById('stage3Title');
            const stageLuckyTitle = document.getElementById('stageLuckyTitle');
            const stageFullTitle = document.getElementById('stageFullTitle');
            
            if (!stage1 || !stage2 || !stage3 || !stageLucky || !stageFull) return;
            
            // Reset t·∫•t c·∫£ v·ªÅ inactive
            stage1.classList.remove('active');
            stage2.classList.remove('active');
            stage3.classList.remove('active');
            stageLucky.classList.remove('active');
            stageFull.classList.remove('active');
            
            // C·∫≠p nh·∫≠t countdown v√† tr·∫°ng th√°i theo turnCount
            if (turnCount < 5) {
                stage1.classList.add('active');
                if (stage1Title) {
                    stage1Title.textContent = `Giai ƒëo·∫°n 1 (‚è±Ô∏è c√≤n ${5 - turnCount} l∆∞·ª£t)`;
                }
                if (stage2Title) {
                    stage2Title.textContent = `Giai ƒëo·∫°n 2 (‚è±Ô∏è c√≤n ${5 - turnCount} l∆∞·ª£t)`;
                }
                if (stage3Title) {
                    stage3Title.textContent = `Giai ƒëo·∫°n 3 (‚è±Ô∏è c√≤n ${10 - turnCount} l∆∞·ª£t)`;
                }
                if (stageLuckyTitle) {
                    stageLuckyTitle.textContent = 'Ng∆∞·ªùi ch∆°i may m·∫Øn';
                }
            } else if (turnCount < 10) {
                stage1.classList.add('active');
                stage2.classList.add('active');
                if (stage1Title) {
                    stage1Title.textContent = 'Giai ƒëo·∫°n 1 (‚úÖ ƒë√£ ho√†n th√†nh)';
                }
                if (stage2Title) {
                    stage2Title.textContent = `Giai ƒëo·∫°n 2 (‚è±Ô∏è c√≤n ${10 - turnCount} l∆∞·ª£t)`;
                }
                if (stage3Title) {
                    stage3Title.textContent = `Giai ƒëo·∫°n 3 (‚è±Ô∏è c√≤n ${10 - turnCount} l∆∞·ª£t)`;
                }
                if (stageLuckyTitle) {
                    stageLuckyTitle.textContent = 'Ng∆∞·ªùi ch∆°i may m·∫Øn';
                }
            } else {
                stage1.classList.add('active');
                stage2.classList.add('active');
                stage3.classList.add('active');
                if (stage1Title) {
                    stage1Title.textContent = 'Giai ƒëo·∫°n 1 (‚úÖ ƒë√£ ho√†n th√†nh)';
                }
                if (stage2Title) {
                    stage2Title.textContent = 'Giai ƒëo·∫°n 2 (‚úÖ ƒë√£ ho√†n th√†nh)';
                }
                if (stage3Title) {
                    stage3Title.textContent = 'Giai ƒëo·∫°n 3 (‚úÖ ƒë√£ ho√†n th√†nh)';
                }
                
                // Sau l∆∞·ª£t 10, hi·ªÉn th·ªã giai ƒëo·∫°n may m·∫Øn
                if (turnCount > 10) {
                    stageLucky.classList.add('active');
                    if (stageLuckyTitle) {
                        const remaining = 7 - ((turnCount - 10) % 7);
                        if (remaining === 7) {
                            stageLuckyTitle.textContent = 'Ng∆∞·ªùi ch∆°i may m·∫Øn (‚è±Ô∏è ƒë·∫øn l∆∞·ª£t!)';
                        } else {
                            stageLuckyTitle.textContent = `Ng∆∞·ªùi ch∆°i may m·∫Øn (‚è±Ô∏è c√≤n ${remaining} l∆∞·ª£t)`;
                        }
                    }
                } else {
                    if (stageLuckyTitle) {
                        stageLuckyTitle.textContent = 'Ng∆∞·ªùi ch∆°i may m·∫Øn';
                    }
                }
                
                // Hi·ªÉn th·ªã giai ƒëo·∫°n thanh t·∫©y khi ƒë·∫ßy
                if (hasPerformedFullCleanse) {
                    stageFull.classList.add('active');
                    if (stageFullTitle) {
                        stageFullTitle.textContent = 'Thanh t·∫©y khi ƒë·∫ßy (‚úÖ ƒë√£ ho√†n th√†nh)';
                    }
                } else {
                    // Ki·ªÉm tra xem t·∫•t c·∫£ √¥ ƒë√£ c√≥ t√™n ng∆∞·ªùi ch∆°i ch∆∞a
                    let allCellsHavePlayers = true;
                    for (let i = 1; i < TOTAL_CELLS; i++) {
                        if (cells[i].dataset.type !== 'player' || cells[i].dataset.won === 'true') {
                            allCellsHavePlayers = false;
                            break;
                        }
                    }
                    
                    if (allCellsHavePlayers) {
                        stageFull.classList.add('active');
                        if (stageFullTitle) {
                            stageFullTitle.textContent = 'Thanh t·∫©y khi ƒë·∫ßy (‚è±Ô∏è ƒë·∫øn l∆∞·ª£t!)';
                        }
                    } else {
                        if (stageFullTitle) {
                            stageFullTitle.textContent = 'Thanh t·∫©y khi ƒë·∫ßy';
                        }
                    }
                }
            }
        }

        // C·∫≠p nh·∫≠t countdown l∆∞·ª£t may m·∫Øn (gi·ªØ l·∫°i ƒë·ªÉ t∆∞∆°ng th√≠ch, nh∆∞ng kh√¥ng d√πng n·ªØa)
        function updateLuckyCountdown() {
            // Kh√¥ng c·∫ßn c·∫≠p nh·∫≠t n·ªØa v√¨ ƒë√£ chuy·ªÉn sang stages
            updateStages();
        }

        // X·ª≠ l√Ω modal Lu·∫≠t ch∆°i
        const rulesBtn = document.getElementById('rulesBtn');
        const rulesModal = document.getElementById('rulesModal');
        const rulesModalClose = document.getElementById('rulesModalClose');
        
        if (rulesBtn) {
            rulesBtn.addEventListener('click', function() {
                rulesModal.classList.add('active');
            });
        }
        
        if (rulesModalClose) {
            rulesModalClose.addEventListener('click', function() {
                rulesModal.classList.remove('active');
            });
        }
        
        // ƒê√≥ng modal khi click b√™n ngo√†i
        if (rulesModal) {
            rulesModal.addEventListener('click', function(e) {
                if (e.target === rulesModal) {
                    rulesModal.classList.remove('active');
                }
            });
        }

        // Kh·ªüi t·∫°o
        initGrid();
        checkStartButton(); // Ki·ªÉm tra tr·∫°ng th√°i n√∫t khi trang load
        loadGameData(); // Load d·ªØ li·ªáu khi trang load
        updateStages(); // C·∫≠p nh·∫≠t c√°c giai ƒëo·∫°n khi trang load
        
        // ƒê·∫£m b·∫£o n√∫t Nh√¢n Ph·∫©m hi·ªÉn th·ªã nh∆∞ng disabled v√† ch√¨m ban ƒë·∫ßu
        const diceBtn = document.getElementById('diceBtn');
        if (diceBtn && !gameStarted) {
            diceBtn.style.display = 'block';
            diceBtn.disabled = true;
            diceBtn.style.opacity = '0.3';
            diceBtn.style.cursor = 'not-allowed';
            diceBtn.style.transform = 'scale(0.95)';
        }

        // Ph√°t hi·ªán thi·∫øt b·ªã di ƒë·ªông v√† hi·ªÉn th·ªã popup c·∫£nh b√°o
        function isMobileDevice() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());
            const isSmallScreen = window.innerWidth <= 768 || window.innerHeight <= 600;
            return isMobile || isSmallScreen;
        }

        function showMobileWarning() {
            // Ki·ªÉm tra xem ƒë√£ ƒë√≥ng popup ch∆∞a (l∆∞u trong localStorage)
            const warningDismissed = localStorage.getItem('mobileWarningDismissed');
            if (!warningDismissed && isMobileDevice()) {
                const modal = document.getElementById('mobileWarningModal');
                if (modal) {
                    modal.classList.add('active');
                }
            }
        }

        function closeMobileWarning() {
            const modal = document.getElementById('mobileWarningModal');
            if (modal) {
                modal.classList.remove('active');
                localStorage.setItem('mobileWarningDismissed', 'true');
            }
        }

        // X·ª≠ l√Ω s·ª± ki·ªán ƒë√≥ng popup
        const mobileWarningModal = document.getElementById('mobileWarningModal');
        const mobileWarningClose = document.getElementById('mobileWarningClose');
        const mobileWarningBtn = document.getElementById('mobileWarningBtn');

        if (mobileWarningClose) {
            mobileWarningClose.addEventListener('click', closeMobileWarning);
        }

        if (mobileWarningBtn) {
            mobileWarningBtn.addEventListener('click', closeMobileWarning);
        }

        if (mobileWarningModal) {
            mobileWarningModal.addEventListener('click', function(e) {
                if (e.target === mobileWarningModal) {
                    closeMobileWarning();
                }
            });
        }

        // Hi·ªÉn th·ªã popup khi trang load (n·∫øu l√† thi·∫øt b·ªã di ƒë·ªông)
        window.addEventListener('load', function() {
            setTimeout(showMobileWarning, 500); // Delay 500ms ƒë·ªÉ trang load xong
        });
    </script>
</body>
</html>
